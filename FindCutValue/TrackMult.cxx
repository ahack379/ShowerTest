#ifndef LARLITE_TRACKMULT_CXX
#define LARLITE_TRACKMULT_CXX

#include "TrackMult.h"
#include "DataFormat/hit.h"
#include "DataFormat/vertex.h"
#include "DataFormat/mctruth.h"
#include "DataFormat/event_ass.h"
#include "DataFormat/track.h"
#include "LArUtil/GeometryHelper.h"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <math.h>

namespace larlite {

  bool TrackMult::initialize() {

   _event = -1 ;
   _track_mult = 0;

   if( !_tree ){
     _tree = new TTree("tree","tree");
     _tree->Branch("length_v","std::vector<float>",&_length_v); 
     _tree->Branch("track_mult",&_track_mult,"track_mult/I"); 
     _tree->Branch("nue_event",&_nue_event,"nue_event/B"); 
     _tree->Branch("ccpi0_event",&_ccpi0_event,"ccpi0_event/I"); 
     _tree->Branch("nu_energy",&_nu_energy,"nu_energy/I"); 
     _tree->Branch("length",&_length,"length/I"); 
     _tree->Branch("pid",&_pid,"pid/I"); 
    }   

// This list is CCPi0 no mesons
//_good_list = {39,48,59,62,76,79,100,103,106,119,157,160,171,190,208,217,269,286,292,319,321,364,371,391,397,419,424,429,437,448,452,484,487,489,493,504,506,517,533,542,577,597,612,620,655,673,681,732,751,762,776,786,840,846,849,853,869,897,919,931,943,964,971,1034,1037,1045,1047,1090,1093,1123,1129,1144,1147,1161,1190,1219,1225,1243,1275,1285,1308,1325,1328,1359,1385,1391,1394,1404,1411,1430,1438,1446,1475,1490,1509,1516,1533,1541,1545,1561,1573,1612,1643,1645,1651,1661,1666,1671,1707,1709,1726,1736,1780,1801,1805,1845,1859,1861,1886,1897,1919,1940,1944,1945,1949,1983,1984,1995,2027,2037,2044,2049,2056,2121,2122,2132,2141,2151,2163,2171,2174,2195,2215,2223,2236,2259,2263,2265,2285,2320,2338,2352,2372,2391,2398,2413,2417,2420,2424,2428,2435,2471,2489,2496,2498,2560,2573,2576,2604,2615,2698,2709,2739,2799,2875,2897,2933,2981,2986,2995,3000,3019,3031,3057,3075,3077,3078,3118,3123,3127,3135,3143,3164,3204,3206,3207,3225,3246,3249,3265,3267,3306,3312,3327,3346,3362,3381,3414,3433,3504,3517,3542,3547,3552,3581,3601,3611,3612,3638,3718,3740,3783,3784,3827,3828,3844,3846,3860,3861,3880,3898,3908,3918,3927,3949,3959,3963,3974,3984,4062,4090,4104,4135,4136,4141,4148,4157,4184,4205,4226,4229,4263,4341,4352};

// This list is all background using CCpi0 no mesons definition
  _bad_list = {29,40,47,49,104,143,149,158,162,184,196,221,225,230,247,268,271,306,315,316,320,393,408,417,420,440,441,460,469,476,502,507,514,523,579,583,599,615,627,631,645,689,736,750,757,768,787,790,800,803,805,812,813,825,827,845,854,875,882,893,905,906,912,923,932,938,946,955,956,997,1023,1026,1039,1115,1116,1120,1122,1138,1141,1154,1193,1205,1216,1223,1227,1260,1299,1305,1306,1313,1337,1338,1355,1384,1452,1461,1468,1469,1477,1485,1499,1529,1539,1551,1554,1560,1585,1588,1591,1598,1623,1646,1663,1665,1668,1669,1672,1675,1690,1691,1699,1717,1735,1760,1763,1764,1771,1777,1786,1793,1795,1798,1804,1811,1820,1848,1849,1866,1871,1874,1878,1887,1896,1903,1926,1939,1946,1961,1962,1966,2004,2017,2028,2031,2033,2058,2066,2071,2074,2079,2082,2083,2089,2100,2167,2201,2227,2239,2307,2311,2314,2354,2355,2375,2386,2388,2393,2395,2408,2427,2431,2433,2440,2455,2465,2478,2488,2490,2492,2503,2506,2513,2535,2536,2550,2552,2592,2631,2649,2659,2663,2699,2731,2736,2746,2808,2830,2831,2838,2851,2878,2883,2889,2906,2913,2914,2920,2950,2955,2968,2979,2980,2998,2999,3011,3034,3071,3086,3111,3134,3138,3155,3156,3165,3171,3182,3184,3214,3254,3277,3285,3307,3338,3348,3350,3352,3357,3363,3373,3389,3392,3398,3411,3434,3444,3445,3461,3465,3471,3474,3484,3490,3499,3514,3520,3548,3558,3608,3618,3620,3622,3628,3640,3648,3668,3681,3701,3724,3731,3744,3755,3774,3777,3799,3848,3854,3866,3869,3885,3887,3888,3897,3905,3925,3934,3951,3954,3960,3970,3988,4007,4019,4032,4034,4046,4051,4058,4059,4063,4066,4079,4109,4128,4138,4147,4160,4167,4177,4240,4247,4256,4278,4294,4304,4312,4313,4316,4325,4334,4338,4340}; 

 // This list is CC pi0 with mesons in final state
 _good_list = { 29, 39, 48, 59, 62, 76, 79, 100, 103, 106, 119, 157, 160, 171, 184, 190, 196, 208, 217, 269, 286, 292, 306, 316, 319, 321, 364, 371, 391, 397, 419, 424, 429, 437, 440, 448, 452, 460, 484, 487, 489, 493, 502, 504, 506, 514, 517, 533, 542, 577, 597, 612, 615, 620, 655, 673, 681, 732, 750, 751, 762, 768, 776, 786, 790, 800, 803, 840, 846, 849, 853, 869, 882, 893, 897, 912, 919, 931, 943, 964, 971, 1034, 1037, 1045, 1047, 1090, 1093, 1120, 1122, 1123, 1129, 1138, 1141, 1144, 1147, 1161, 1190, 1193, 1216, 1219, 1225, 1243, 1260, 1275, 1285, 1308, 1313, 1325, 1328, 1359, 1384, 1385, 1391, 1394, 1404, 1411, 1430, 1438, 1446, 1452, 1468, 1475, 1485, 1490, 1509, 1516, 1533, 1541, 1545, 1554, 1561, 1573, 1591, 1612, 1643, 1645, 1646, 1651, 1661, 1666, 1671, 1675, 1691, 1707, 1709, 1726, 1735, 1736, 1763, 1771, 1780, 1793, 1801, 1805, 1820, 1845, 1859, 1861, 1886, 1887, 1896, 1897, 1919, 1940, 1944, 1945, 1949, 1962, 1966, 1983, 1984, 1995, 2027, 2028, 2037, 2044, 2049, 2056, 2058, 2071, 2082, 2121, 2122, 2132, 2141, 2151, 2163, 2171, 2174, 2195, 2215, 2223, 2236, 2239, 2259, 2263, 2265, 2285, 2307, 2311, 2320, 2338, 2352, 2354, 2355, 2372, 2386, 2391, 2395, 2398, 2413, 2417, 2420, 2424, 2428, 2435, 2465, 2471, 2478, 2489, 2496, 2498, 2506, 2536, 2560, 2573, 2576, 2604, 2615, 2659, 2698, 2709, 2731, 2736, 2739, 2799, 2808, 2830, 2875, 2883, 2897, 2913, 2920, 2933, 2980, 2981, 2986, 2995, 3000, 3019, 3031, 3057, 3071, 3075, 3077, 3078, 3118, 3123, 3127, 3134, 3135, 3143, 3155, 3164, 3165, 3171, 3204, 3206, 3207, 3225, 3246, 3249, 3265, 3267, 3306, 3312, 3327, 3346, 3348, 3350, 3362, 3381, 3392, 3411, 3414, 3433, 3434, 3484, 3490, 3504, 3517, 3520, 3542, 3547, 3552, 3558, 3581, 3601, 3611, 3612, 3622, 3638, 3668, 3718, 3740, 3744, 3783, 3784, 3827, 3828, 3844, 3846, 3848, 3860, 3861, 3866, 3880, 3887, 3888, 3898, 3905, 3908, 3918, 3927, 3949, 3951, 3954, 3959, 3963, 3974, 3984, 4034, 4046, 4062, 4066, 4090, 4104, 4135, 4136, 4138, 4141, 4148, 4157, 4184, 4205, 4226, 4229, 4240, 4256, 4263, 4312, 4313, 4334, 4341, 4352};

    return true;
  }
  
  bool TrackMult::analyze(storage_manager* storage) {

    auto const& geomH = ::larutil::GeometryHelper::GetME();

    _event++;
    _track_mult = 0;
    _nue_event = false;
    _ccpi0_event = false;
    _nu_energy = 0;
    _length = 0;
    _pid = 0;

    //if ( std::find(_good_list.begin(),_good_list.end(),_event) == _good_list.end() )
    //        return false;
    //if ( std::find(_bad_list.begin(),_bad_list.end(),_event) == _bad_list.end() )
    //        return false;

    std::cout<<"\nNew event! "<<_event<<std::endl ;

    auto ev_vtx = storage->get_data<event_vertex>("numuCC_vertex");
    if ( !ev_vtx || !ev_vtx->size() ) return false; 

    auto ev_trk = storage->get_data<event_track>("pandoraNu");
    if ( !ev_trk || !ev_trk->size() ) return false; 

    auto ev_truth = storage->get_data<event_mctruth>("generator");
    if ( !ev_truth || !ev_truth->size() ) return false; 
    
    auto const & nu = ev_truth->at(0).GetNeutrino().Nu();
    if ( abs(nu.PdgCode()) == 12 )
      _nue_event = true;
    else
      _ccpi0_event = true;


    _nu_energy = nu.Trajectory().at(0).E() ;

    auto vtx = ev_vtx->at(0); 
    std::vector<double> vtxXYZ = { vtx.X(), vtx.Y(), vtx.Z() };

    std::vector<int> trk_ids;
    trk_ids.reserve(ev_trk->size());
    
    //Map of lengths -> track id
    std::multimap<float,int> trk_map ;
    _length_v.clear();

    int rad_its = 3; // Go from 1 to 9 cm

      //for(int j = 1; j < rad_its + 1; j++){
      int j = 2;

      // Find closest + longest pandoraNu track to vertex
      for ( size_t ti = 0; ti < ev_trk->size(); ti++ ) { //auto const & v : ev_vtx_pandoraNu ){

        auto t_vtx = ev_trk->at(ti).Vertex() ;
        auto t_end = ev_trk->at(ti).End() ;
         
        float dist_st = sqrt( pow(t_vtx.X() - vtxXYZ[0],2) + 
                              pow(t_vtx.Y() - vtxXYZ[1],2) + 
                              pow(t_vtx.Z() - vtxXYZ[2],2) ); 

        float dist_end = sqrt( pow(t_end.X() - vtxXYZ[0],2) + 
                               pow(t_end.Y() - vtxXYZ[1],2) + 
                               pow(t_end.Z() - vtxXYZ[2],2) ); 
         if ( dist_st < j || dist_end < j ){
            float len = ev_trk->at(ti).Length();
            _length_v.emplace_back(len);
            trk_ids.emplace_back(ti);
            trk_map.emplace(1./len,ti);

            // Quantities only used for single track mult study
	    _length = len ; 
	    //_pid = ev_trk->at(ti).PdgCode() ;

	    std::cout<<"length: "<<len<<std::endl ;
             }

          }
       std::cout<<"Tracks within "<<j<<" cm: "<<_length_v.size()<<std::endl; 
       _track_mult = _length_v.size() ;
       //}
    
    _tree->Fill();



    return true;
  }

  bool TrackMult::finalize() {

    if(_fout) { _fout->cd(); _tree->Write(); }

    return true;
  }

}
#endif
