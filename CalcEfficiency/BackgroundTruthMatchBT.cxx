#ifndef LARLITE_BACKGROUNDTRUTHMATCHBT_CXX
#define LARLITE_BACKGROUNDTRUTHMATCHBT_CXX

#include "TH1D.h"
#include "TDirectory.h"

#include "BackgroundTruthMatchBT.h"
#include "DataFormat/mctruth.h"
#include "DataFormat/mcshower.h"
#include "DataFormat/mctrack.h"
#include "DataFormat/track.h"
#include "DataFormat/shower.h"
#include "DataFormat/vertex.h"
#include "DataFormat/cluster.h"
#include "DataFormat/opflash.h"
#include "DataFormat/hit.h"
#include "DataFormat/mceventweight.h"
#include "DataFormat/calorimetry.h"

#include "LArUtil/GeometryHelper.h"
#include "LArUtil/DetectorProperties.h"

namespace larlite {

  bool BackgroundTruthMatchBT::initialize() {    

    _map_v.resize(10,std::multimap<float,float>());
    _event_no_dup = 0;
    _event = -1; 

    _n_signals =0 ;

    // Count signal + backgrounds in sample
    _n_noise = 0;    // 0
    _n_cosmic = 0;   // 1         
    _n_cc1pi0 = 0;   // 2
    _n_nc1pi0 = 0;   // 3
    _n_cc1pi0_outFV = 0;  // 4
    _n_multpi0 = 0;  // 5
    _n_nue = 0;      // 6 
    _n_antimu  = 0;   // 7
    _n_cccex = 0;    // 8
    _n_nccex = 0;    // 9
    _n_gamma = 0 ; // 10
    _n_kaondecay = 0 ; // 11
    _n_ccother = 0;  // 12
    _n_ncother = 0;  // 13
    _n_other = 0;    // 14 
    _bkgd_v = { "Other","Cosmic","CC1pi0","NC1pi0","CC1pi0_outFV","Multpi0", "nue","antinumu","cccex","nccex","ccgamma","kaondecay","ccother","ncother" };

    // Check single gamma events for blindness
    _1gamma = 0;

    _SCE = new larutil::SpaceChargeMicroBooNE();
    _time2cm = larutil::GeometryHelper::GetME()->TimeToCm();

    // This part only applicable when trying to calculate GENIE xsec uncertainties
    if ( _get_genie_info ){ //&& _eventweight_producer == "genieeventweight" ){
      _genie_label_v = {"AGKYpT","AGKYxF","DISAth","DISBth","DISCv1u","DISCv2u","FermiGasModelKf", "FermiGasModelSf","FormZone", "IntraNukeNabs", "IntraNukeNcex", "IntraNukeNel", "IntraNukeNinel", "IntraNukeNmfp", "IntraNukeNpi", "IntraNukePIabs", "IntraNukePIcex", "IntraNukePIel", "IntraNukePIinel", "IntraNukePImfp", "IntraNukePIpi", "NC", "NonResRvbarp1pi", "NonResRvbarp2pi", "NonResRvp1pi", "NonResRvp2pi", "ResDecayEta", "ResDecayGamma", "ResDecayTheta", "ccresAxial", "ccresVector", "cohMA", "cohR0", "ncelAxial", "ncelEta", "ncresAxial", "ncresVector", "qema", "qevec"};

      int genie_funcs = _genie_label_v.size() ; //78 total, +- for each func

      _sel_evts_m1.resize(genie_funcs,0) ;
      _sel_evts_p1.resize(genie_funcs,0) ;

      _sig_evts_m1.resize(genie_funcs,0) ;
      _sig_evts_p1.resize(genie_funcs,0) ;

      _bkgd_evts_p1.resize(genie_funcs,0) ;
      _bkgd_evts_m1.resize(genie_funcs,0) ;

    //} 
    // This part only applicable when trying to calculate flux xsec uncertainties
    //if ( _get_genie_info && _eventweight_producer == "fluxeventweight"){

      int funcs = 6;
      _sig_v.resize(funcs);
      _tot_v.resize(funcs);
      _eff_v.resize(funcs);
      _bkgd_v.resize(funcs);
      _xsec_v.resize(funcs);
      _perc_v.resize(funcs);
      _s_weights_by_universe.resize(funcs);
      _b_weights_by_universe.resize(funcs);
      _flux_by_universe.resize(funcs);

      for ( int i = 0; i < funcs ; i++ ){
        _s_weights_by_universe.at(i).resize(1000,0) ;
        _b_weights_by_universe.at(i).resize(1000,0) ;
        _flux_by_universe.at(i).resize(1000,0) ;
        _sig_v.at(i).resize(1000,0);
        _tot_v.at(i).resize(1000,0);
        _eff_v.at(i).resize(1000,0);
        _bkgd_v.at(i).resize(1000,0);
        _xsec_v.at(i).resize(1000,0);
        _perc_v.at(i).resize(1000,0);
      }
       std::cout<<"ENTERING ! "<<std::endl ;
  
       TFile * f = new TFile("/uboone/app/users/jaz8600/FastFluxFiles/MCC8_FluxHistograms_Uncertainties.root");
       TDirectory *C_dir_numu = (TDirectory*) f-> Get("numu");

       TH1D * hcv = (TH1D*) C_dir_numu->Get("numu_CV_AV_TPC") ;
       hcv->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
       
       TDirectory *C_dir_unisim = (TDirectory*) C_dir_numu -> Get("FluxUnisim");
       TDirectory *C_dir_av  = (TDirectory*) C_dir_unisim -> Get("Active_TPC_Volume");
       TDirectory *piplus = (TDirectory*) C_dir_numu -> Get("piplus");
       TDirectory *piplus_av = (TDirectory*) piplus -> Get("Active_TPC_Volume");
       TDirectory *piminus = (TDirectory*) C_dir_numu -> Get("piminus");
       TDirectory *piminus_av = (TDirectory*) piminus -> Get("Active_TPC_Volume");
       TDirectory *kplus = (TDirectory*) C_dir_numu -> Get("kplus");
       TDirectory *kplus_av = (TDirectory*) kplus -> Get("Active_TPC_Volume");
       TDirectory *kminus = (TDirectory*) C_dir_numu -> Get("kminus");
       TDirectory *kminus_av = (TDirectory*) kminus -> Get("Active_TPC_Volume");
       TDirectory *kzero = (TDirectory*) C_dir_numu -> Get("kzero");
       TDirectory *kzero_av = (TDirectory*) kzero -> Get("Active_TPC_Volume");

       for( int j =0; j < 6; j++){
         std::cout<<"New funtion ! "<<std::endl ;
         for(int i = 0; i < 1000; i++){

           // Non-hadron pieces
           if ( j == 0 ) { 
             TH1D * h1 = (TH1D*) C_dir_av->Get(Form("numu_FluxUnisim_Uni_%d_AV_TPC",i)) ;
             h1->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
             _flux_by_universe[j][i] = h1->Integral() ; 
           }
           else if ( j == 1 ){
             TH1D * h1 = (TH1D*) kplus_av->Get(Form("numu_kplus_Uni_%d_AV_TPC",i)) ;
             h1->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
             _flux_by_universe[j][i] = h1->Integral() ; 
           }
           else if ( j == 2 ){
             TH1D * h1 = (TH1D*) kminus_av->Get(Form("numu_kminus_Uni_%d_AV_TPC",i)) ;
             h1->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
             _flux_by_universe[j][i] = h1->Integral() ; 
           }
           else if ( j == 3 ){
             TH1D * h1 = (TH1D*) kzero_av->Get(Form("numu_kzero_Uni_%d_AV_TPC",i)) ;
             h1->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
             _flux_by_universe[j][i] = h1->Integral() ; 
           }
           else if ( j == 4 ){ 
             TH1D * h1 = (TH1D*) piplus_av->Get(Form("numu_piplus_Uni_%d_AV_TPC",i)) ;
             h1->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
             _flux_by_universe[j][i] = h1->Integral() ; 
           }
           else if ( j == 5 ) { 
             TH1D * h1 = (TH1D*) piminus_av->Get(Form("numu_piminus_Uni_%d_AV_TPC",i)) ;
             h1->Scale(1.616*1e20/(2.43e11)/(256.35 * 233.));
             _flux_by_universe[j][i] = h1->Integral() ; 
           }
         }
       }
      delete f ;
     }


   _unisim_label_v = {"SkinEffect","HornCurrent","NucleonInXsec","NucleonQEXsec","NucleonTotXsec","piInelasticXsec","piInelasticXsec","piQEXsec","piTotalXsec"};
   _label_map = { {"K+", 1} , {"K-",2}, {"K0",3}, {"pi+",4}, {"pi-",5} } ;
  _t_weights_by_universe = {{38807.6, 35843.4, 43764.7, 34346.3, 34686.8, 39516.4, 41229.2, 33184.6, 40654.3, 42513.1, 43007, 40729.1, 38455.5, 42697.2, 40241.1, 39124, 35699.3, 40498.6, 39238.1, 38239.1, 37801.9, 36993.4, 35727, 38046.6, 36187.1, 36416.3, 41150.5, 40461.1, 42780.2, 36388.5, 38720.7, 39670.5, 40138.8, 35221.5, 36950.7, 38525.3, 40390.9, 40206.5, 40648.1, 39770.8, 38231.5, 38029.7, 37768.5, 39359.1, 37621.4, 34456.4, 37711, 35596.4, 35063.6, 33134.3, 37234.8, 38252, 36724.7, 38975.7, 38241.3, 39513.8, 40143, 35118.8, 41865.7, 37313.1, 39303.4, 37841.2, 39820.8, 40367.6, 41216.7, 38616.3, 38487.8, 33712.1, 39750.2, 40417.7, 38511, 46161.1, 38660.1, 42430.8, 34309, 39677.6, 41604.6, 35349, 43093.2, 39115.6, 42213.8, 37996.9, 37240.2, 41144.1, 35022.3, 33909.3, 37795.3, 39127.4, 36629.3, 37422.1, 36966.5, 36443.3, 39151.3, 35142.6, 38129.2, 32473.5, 35162.8, 36412.1, 38256.9, 34891.9, 36708.4, 35136.7, 38136.3, 35608.2, 35495.4, 37216.7, 34881.6, 36808.3, 36743.4, 39246.1, 37169.6, 39978.1, 37101.9, 40202.9, 38758.9, 35654.2, 36959.5, 37086.5, 36648.3, 40091.3, 37337.5, 37387.2, 35044.7, 34607.1, 42555.8, 38547.2, 36417.8, 36809.2, 42243.2, 34422.6, 40409, 43041.3, 36621.9, 37729.7, 37617.9, 36985.9, 36697.5, 37954.6, 41296.6, 37028.4, 40666.9, 37880.3, 38497.1, 42821.2, 37460.2, 40454.4, 40592.2, 34570.2, 39048.7, 38346.2, 41461.8, 39944.5, 41887.9, 39875.5, 37453.2, 35397, 36752.3, 33006.1, 40001.1, 38590.3, 41328.6, 34764.1, 37419.1, 41871.2, 40210.2, 35694.2, 38944.6, 41251.4, 39909.6, 45617.6, 38198.8, 41490.1, 36506.2, 38576.8, 39843.7, 39203, 38681.2, 40519.4, 34552.3, 35039.4, 35627.3, 37268.4, 35674.8, 37892.4, 36707, 38561.7, 39048.6, 41643.3, 39487.8, 36753.5, 36564.4, 40398.5, 39337.4, 33739, 37029.6, 32417.9, 32823.6, 35161.1, 42613.1, 35167.7, 38486.4, 39159, 39830.6, 39745, 36450.2, 38482.5, 38695.4, 40391.7, 38643.2, 34827.9, 37621.5, 40152.6, 38061.1, 41094.9, 42879.4, 35918.9, 37859.9, 38459.6, 35314.3, 41855.7, 36865.6, 34558.5, 35390.1, 33541.1, 38143.3, 39631.3, 39947.5, 38311.8, 37268.7, 36989.4, 39856.2, 36892.5, 38205.1, 38475.4, 37252.8, 35963.1, 39829.7, 36751, 38521.8, 37427.8, 35959.7, 37573.7, 37475.5, 40087.5, 37585.6, 40815.7, 39616.4, 35742.9, 38385, 38213.6, 36069.4, 39180.4, 38568.4, 36595.3, 37643.7, 37338.5, 36838.6, 35282.6, 37772, 36147.4, 40810.8, 38914.9, 33367.6, 34122.2, 36126.6, 38865.1, 35700.1, 39926.7, 38045, 42089.1, 36240, 37822.4, 34303.3, 40179.3, 38821.7, 41170.9, 40726.7, 38960.8, 37508, 34925.1, 39046.1, 34254.5, 35656, 37563.8, 39686.7, 39705.5, 33890.1, 39068.1, 36352.9, 39442.8, 40412.3, 39162.3, 39071.9, 39576.1, 37570, 34737.1, 33198.4, 36799.8, 39707.9, 37266.8, 37451.9, 34265.6, 40852.8, 37654, 38492.5, 37274.2, 38220.5, 37795.3, 35915.5, 36640, 36444.7, 43502.4, 38868.3, 37540, 37465.2, 37219.3, 34353.3, 32050, 36857.2, 36738.6, 32340.3, 41460.6, 37434.7, 39673.7, 37936.3, 42773.6, 40537.1, 39372.3, 37351.1, 36469.4, 39122.7, 36736.2, 38896.6, 40514, 31375.6, 35812.7, 36088.7, 41647.3, 33783.2, 40908.5, 36901.3, 39265, 33691.5, 35967.1, 40100.8, 36790.2, 37330.9, 39408.1, 39039.5, 36553.4, 39245.6, 40216.2, 34599.9, 42427.9, 42231.6, 36563.8, 38890.2, 40569.3, 40681.5, 39348.1, 38832.9, 41067.5, 36342.1, 37807.8, 35552.7, 42357.7, 38186.4, 36538.1, 40623.1, 41715.5, 34166.3, 34653.1, 36217.4, 38952.3, 38103.7, 38729.1, 39750.2, 39536.8, 42378.1, 41973.5, 39454.8, 34986, 38560.8, 39779.7, 38450.3, 41287.1, 37677.9, 41156.5, 37336.8, 40960.2, 42132.7, 35364.1, 33641.1, 35975.6, 37425.2, 32422.6, 38055.8, 41868.3, 38802.8, 40613.9, 34310.2, 36918.9, 37382.6, 35478.5, 41777.1, 36109.7, 37566.8, 38986.1, 36689.4, 38016.1, 38244.8, 41273.8, 35530.8, 39132.9, 37617.5, 39008.3, 34631.6, 37487.1, 38824.6, 40199, 36738.5, 42990.5, 37572.4, 38365.3, 37638.4, 36793.4, 39880.9, 37258.4, 35256.5, 36372.8, 39549.6, 39027.7, 39075.2, 37166.7, 42568.3, 38495.7, 37835.5, 37907.4, 39700.4, 37673.4, 36037.2, 35880.6, 36611.9, 40539, 34451.4, 36934.3, 41776.1, 40190.3, 35621.6, 37655.2, 37194.8, 37193.3, 36976.1, 39689.6, 39522.5, 38889.2, 40373, 35930.5, 36335.7, 31530.6, 40931.3, 35009.5, 36523.1, 37906.6, 33395.1, 37107.7, 40210.5, 40493.7, 38409.7, 37999.9, 39268.9, 35177.1, 41820.1, 42241.5, 43459.6, 39979.7, 40647.6, 36653.6, 40185.1, 36624.3, 37666.5, 38298.6, 43466.9, 33507.4, 36597.9, 42757.6, 38910.5, 38900.8, 38963.7, 35405.8, 36901.2, 37319.5, 33765.2, 42049.6, 39502.8, 40425.9, 35246.5, 38661.2, 39137.7, 41885.2, 41671.1, 36657.9, 36875.2, 37687.7, 36210.8, 36829.9, 45365.9, 40000.6, 37147.3, 32604.5, 33511, 36963.7, 36961.6, 37773.2, 41285.1, 33405.2, 39855.7, 36854.7, 32720.4, 43331.5, 38347.7, 36639.2, 39775.6, 35389.5, 38529.6, 37327.4, 41046.1, 35044.1, 35416.5, 38588.2, 37711.6, 34677.6, 37860.6, 36816.6, 32851.1, 37364.2, 34841.9, 38640.5, 36778.1, 37667.7, 36036, 36770, 35584.1, 42383.5, 36912.2, 39534.3, 40841.5, 37723.7, 34087.2, 38381.9, 37861.7, 37902, 35450.5, 35742.2, 33473.8, 37816.5, 36265, 39036.2, 35504.4, 34457.1, 36161.7, 36409.8, 34336, 41528, 40354.5, 36493.7, 36243.8, 38904.7, 37333.9, 32842.9, 34717.8, 37506.8, 37826.9, 43322.9, 34111.7, 37427.2, 32967.3, 36084.6, 41570, 41393.2, 39967.8, 36544.6, 34821.9, 42438.3, 34677, 36313.7, 39944.9, 38069, 39249.9, 38588.6, 43522.3, 43020.4, 36665.4, 39004.2, 43769.8, 38556.8, 38158.4, 33821.5, 35602.5, 39122.9, 35958.7, 39467, 41719.2, 37761, 37675.4, 38758.5, 35705, 38760.3, 34361.5, 39217, 41801.2, 37537.3, 33971.9, 40419.7, 35258.3, 41340, 39059.4, 35983.9, 39592.8, 41207.7, 41803.2, 41806.5, 35798.7, 41409.3, 39609.7, 40320.8, 37536.9, 36660.3, 39564.7, 39542.1, 36956.3, 38045.2, 39195.1, 38021.8, 43759.1, 35811.1, 33985.2, 39764.4, 37011.7, 33573, 40509.3, 38813.3, 38236.4, 41365.1, 37101.2, 40593.7, 37152.5, 35973, 39110.4, 34489.3, 35592.3, 38504.2, 41471.2, 39965.2, 42236.4, 37220, 36740.5, 40649.8, 36588.6, 36021.7, 37514.4, 37933.6, 43451, 36847, 40561.9, 34810.7, 36817.2, 36024.2, 38809.4, 35381, 37266.5, 38219.6, 38814.6, 39932.5, 32242.5, 39200.9, 41189.7, 39194, 36151, 35161.1, 39800.3, 39120.5, 38939.7, 40099.7, 40221.9, 37148.9, 33121.5, 37930.4, 36227.7, 39013, 35063.7, 38931.2, 42720.2, 41134.1, 38242.3, 37763, 37517.3, 42643.2, 37592.2, 36316.3, 36522.9, 38956, 34579, 34933.2, 45001, 37816.2, 40602.8, 34213.3, 37174.9, 36011.6, 37556.8, 40020.1, 35678.1, 42551.1, 41748.4, 41035.8, 38606.5, 40238.5, 39656.1, 40991.8, 37032.5, 41503.2, 41435.8, 37536, 39634.1, 40458.4, 38865.1, 37487.6, 37013.7, 35235, 35793.2, 38154.1, 36861.4, 39042.2, 43789.2, 42418.3, 32745.2, 38817.9, 42898.6, 37782.1, 35658.2, 37574.1, 40450.9, 39327.4, 36943, 42762.6, 34517.5, 37047.3, 37670.5, 39897.7, 41021.6, 38501.4, 34918.3, 40907.7, 37953.6, 35656.8, 35889.6, 41017.4, 34507.2, 36194.3, 33718.3, 38558.5, 35875.3, 42379.5, 40058.6, 38814.4, 43173.5, 40257.6, 40844.5, 32308.6, 42196.9, 39299.6, 36399, 33194.3, 35723.7, 38776.2, 35200.2, 37128, 38530.4, 40146.2, 39994.2, 42830.6, 36262.5, 42693.7, 34751.1, 37783.6, 32467.1, 38626, 36662.6, 38742.9, 39936.9, 36793.2, 37428.4, 37049.3, 39636, 40067, 36354.7, 35081.7, 35171.6, 37307, 37256.3, 35249.6, 35700.4, 40798.6, 34911.1, 40652.7, 38961, 34487.6, 37165.1, 42390.7, 38994.4, 35159.1, 36615.7, 36268.9, 39876.4, 39775.9, 42455.6, 41059.4, 40254.1, 35156.1, 36777.9, 39124.6, 35424.7, 39547.2, 32829.7, 38075.2, 39737.2, 35841.3, 38129.9, 34162.8, 39506.8, 37732.4, 37657.2, 37649.5, 37113.3, 33958.3, 38011.6, 37270.2, 40020.4, 38207.1, 37958.3, 36930.2, 40676.3, 35131.2, 36702, 39289.6, 35969.2, 36219.2, 42390.6, 35877, 37911.7, 36602.7, 40965.2, 37928.3, 40139.1, 40204.7, 38929.3, 40696.9, 38362.2, 35297.6, 35282.6, 39704.8, 37602.1, 38333.9, 36195, 33977.7, 32996.8, 37036.2, 39828.4, 38264.4, 35519.3, 41439.5, 40331.6, 34737.8, 32679.4, 37645.2, 42205.8, 35853.2, 36495.8, 38912, 39024.6, 39315.5, 37767.8, 38372.1, 36577.1, 36074.2, 41270.1, 37056, 36018.6, 35974.6, 35809.4, 38464, 41701.3, 42768.1, 39325.7, 40915.5, 36572.6, 41259.2, 37340.1, 42080.1, 37961.7, 34904.7, 34245.8, 38522.8, 35665.8, 36668.3, 35837.5, 41881.8, 34876.2, 40586.4, 40076.5, 39066.4, 42046.3, 37500.6, 40645.2, 40521.1, 36106.1, 37877.9, 37173.6, 36456.2, 42525.9, 37827, 44725.8, 33077, 38150.5, 37595.8, 38185.1, 36838, 40383.6, 40505.6, 40466.8, 36668.6, 35482.1, 36542.3, 33829.2, 36233.4, 40346.3, 35948.5, 38364.3, 37230.1, 38446.6, 42048.3, 36698.6, 32916.2, 35481.2, 43312.7, 37215.6, 38193.1, 34815.9, 40227, 33437.7, 44219.4, 35143.8, 35754.3, 39772, 40707.2, 42120, 37179.8, 38324.1, 39913.3, 42164.8, 37165.2, 39940, 35298.7, 38655.6, 35932.8, 38101.8, 38573.2, 41758.8, 38425, 39556.2, 37662.4, 37188.4, 39417.2, 35403.1, 39340.5, 37540.4, 32706.2, 41485.9, 39598.6, 39685, 36218.5, 34619.9, 42307.9, 39815.5, 32286.5, 38163.2, 36207.1, 41653.5, 39420.7, 40072.6, 36289.7, 36097.9, 33350.9, 36322.8, 39137.3, 36859.1, 36617.8, 37287.6, 39426.1},{37556, 37698, 37625.1, 38006.1, 37939.4, 37848.5, 37728.9, 37572.3, 37455.6, 37227.1, 38196.4, 36944.4, 37589.1, 37609.3, 37518.7, 37777.3, 37556.9, 37886.5, 37816.2, 37987.9, 37866.6, 37944, 37623.7, 37643.2, 38008.6, 37612.9, 38217.6, 37434.3, 37165.8, 38250.3, 37408.2, 37210.5, 37851.5, 38030.7, 38096.1, 37714.1, 37856.3, 37517.1, 37923.2, 37463.5, 37715.9, 37235.1, 37934, 37594.6, 37734.3, 37657.2, 37467.7, 37479.5, 37861.3, 37660.4, 37642, 38150.2, 37827.6, 37543.9, 37098.7, 37585.7, 37928.3, 37504.5, 37438.2, 37673.7, 37656, 38057.8, 38352.3, 38028.6, 37916.4, 37540.1, 37874.8, 37725.1, 37858.4, 37508.1, 37375.4, 37622.9, 37408.8, 37379.5, 37888.2, 38217.8, 37728.6, 37673.2, 37314.4, 37961.1, 37723.6, 37507.2, 38292.7, 37618.4, 38019.9, 37452.8, 37304.7, 37414.1, 37177, 37760.1, 37322.2, 37551.7, 38337.3, 37357.9, 37735.5, 37387.1, 37749.9, 38237.3, 38144.9, 37851.4, 37684.1, 37532, 37795.5, 37885, 37817.8, 37280.7, 37881.3, 37728.7, 37898.6, 37873.6, 38309.7, 37443.8, 37702.8, 38062.6, 37407.1, 37893.8, 37093.8, 37905.1, 37539.4, 37687.1, 37580.8, 38309.8, 37708.8, 37610.5, 37923.7, 37625.9, 38011.4, 37128.4, 38126.5, 37984.1, 37528.8, 37591.5, 37354.5, 37856, 37255.2, 37652.3, 37915.4, 38485.7, 37322.2, 37627.8, 37668.5, 37724.2, 37521.9, 37028, 37854, 37467.6, 37963.8, 37939.1, 38037.2, 37507.3, 37712.7, 37974.8, 37487.7, 37455.9, 38022.1, 37345.7, 37668.1, 37211.2, 37754.8, 37792.9, 37629.3, 38213.7, 37650.9, 37538, 38039.5, 37663.6, 37702.3, 37591.4, 37855.8, 37087.6, 37686.6, 37352.5, 37940, 37754.3, 37458.7, 37684.1, 37740.6, 38116, 37625.9, 37780.2, 38018.1, 37486.4, 37561.7, 38149, 37537, 37411.5, 38094.1, 38076.7, 38287.4, 38475.2, 38010.2, 37920, 37634.7, 37723.9, 37946.6, 37090, 37716.3, 37518.5, 37886.6, 37616.8, 37010.3, 37484, 37692.7, 37694.7, 38056.6, 37649.9, 38014.6, 37743.2, 37840.1, 37980.4, 36980.9, 37691.8, 37376.7, 37551.4, 37178.7, 37572.6, 37702.3, 37684.2, 37691.9, 37809.5, 37982.8, 37257.2, 37315.3, 37479.8, 37678.1, 37594.6, 37826.3, 37456.2, 37722.8, 37884.7, 37608.1, 37689.8, 37643.9, 37649.4, 37531.9, 38252.6, 37670.1, 38350.3, 38117.4, 38040.8, 37379.5, 37444.5, 37140.4, 38414.7, 38481.3, 37678.1, 37303.6, 37178.3, 37562.1, 37628.2, 37821, 37275.2, 37200.8, 37490, 37200.6, 37563.6, 37665.2, 37540.7, 37587.9, 37395.3, 37726, 37490.2, 37794.2, 37645.7, 37367.4, 37444, 37894.4, 37680.5, 38053.4, 37640, 38355.4, 37492.5, 38023.2, 37883.2, 37501.8, 37111.5, 38217, 37905.3, 37878.3, 37568.1, 37733.7, 37527.5, 38429, 37557.5, 37832.6, 37293.1, 38349.9, 38111.4, 37023.1, 37323.9, 37841, 38102.9, 37716, 37431.5, 37761, 37909.3, 37858.5, 37845, 38102.5, 38083.5, 37280.3, 37558.5, 37395.9, 37940, 37603, 37363.8, 37392.5, 37867.9, 37796.8, 37429, 38536.1, 37680.8, 38067.5, 37851.5, 37997.5, 37970.5, 38022.5, 37738.2, 38172.1, 38133, 37644.8, 37725.3, 37311, 37441.9, 37945.6, 37718.6, 37689.6, 37084.5, 37857.7, 37444.7, 37891.1, 38002.9, 37956.9, 37892.4, 37931.4, 37312.3, 37543.3, 37477.8, 37373, 37354.6, 37669.8, 37804.3, 37746.1, 37637.2, 37625.5, 37774.4, 37795.6, 37907.2, 37650.3, 37587.8, 38165.9, 37842.2, 37612.4, 37389, 37189.6, 37023.3, 37616.4, 37636.7, 38022.3, 37673.5, 37860.2, 37787.4, 37803.2, 37375.1, 37379.8, 37999.4, 37362.6, 37707.5, 37189.1, 37462.3, 37760.7, 37886.2, 37140.2, 37801.7, 37650.7, 37671.5, 37268.9, 37994.2, 37640, 37741.8, 37607.4, 37398.9, 37917.9, 37789.9, 37627.5, 37433.5, 37754.2, 37461.2, 38057, 37961.3, 37401.9, 38067.2, 37902.2, 37791.5, 37665, 38093.4, 37710.8, 38030.8, 37495.1, 37902.6, 37744.6, 37535.8, 37304, 37511.9, 37995.8, 37994.8, 37830, 37949.6, 38192.4, 37916.1, 37790.7, 37570, 37320.1, 38231.4, 37547.5, 37810.9, 37501.3, 37524.5, 38119.9, 37547.4, 37301.2, 37024.7, 37445.8, 37239.4, 37938.8, 37871.1, 37073.8, 38122.2, 37869.1, 37219.4, 37988.4, 38045.5, 37354.9, 37337.3, 38042.6, 37664.1, 37399.2, 37814.6, 38085.1, 37879, 37894.1, 37291, 37607.5, 37530.7, 37735.4, 37950.2, 37946, 38033.6, 37899, 37419.1, 37352.5, 37781.5, 37783, 37419.6, 38042, 37476.9, 37159.3, 38005.2, 37426.4, 37527.5, 38125.3, 37329, 38120.1, 37431.9, 37817.7, 37887.4, 38173.7, 37525.5, 37947.6, 37987.8, 37836.4, 37467.6, 37890.2, 37365.7, 37642.5, 37760.6, 37301.8, 37874.6, 37823.1, 37299.5, 37622.7, 37887.3, 37943, 37530.8, 38012.1, 38074.2, 37693.8, 37790.2, 36908.9, 38361.6, 37589.3, 37247.1, 38088.6, 38216.6, 37480.8, 37434.4, 37646.3, 37105.6, 37843.9, 37546.6, 38147, 37891.6, 36877, 37711.8, 38210.1, 37871.5, 37790.8, 37178.7, 37576.3, 37724.7, 37492, 37833.7, 37781, 37491.8, 37705.2, 37804.2, 37298.6, 37614, 37480.1, 37318.3, 37230.7, 37813, 37868.9, 37290.6, 37650.5, 37996.7, 38227, 37701.2, 37929.9, 37650.2, 37721.4, 37545, 37554.4, 37620, 37165.9, 37572.5, 37533.1, 38026.5, 37682.7, 37468.2, 37622.8, 37763.1, 38417.7, 37887, 37734.4, 38205.4, 37363.8, 38326.6, 37572.9, 37447, 37786.5, 37564.3, 37961.5, 37487.1, 37490.5, 37704.6, 37339.3, 37271.9, 37666.9, 37527.3, 37128.3, 37916.8, 37646.5, 37981, 37774.4, 37766.9, 37838.3, 37659.2, 37472.3, 37676.2, 37942.9, 37683.8, 37762.3, 38104.6, 37510.5, 37323, 37447.7, 37900.8, 37544, 37154.3, 37516.4, 37592.4, 37783.8, 37797.7, 37296.9, 38143.8, 37430.3, 37660.9, 37825.1, 37145.6, 37127.7, 37602.8, 37444.3, 37475.3, 37660.7, 37552.6, 38390.4, 37378.3, 37595.2, 38066.2, 37396.6, 37600.4, 37974.5, 37687.6, 37341.8, 37137.5, 37249.6, 38241.1, 37875.5, 38111.6, 37979.7, 37472.6, 37284.2, 37551.3, 37814.5, 37977.6, 36918.9, 37483.7, 37719.1, 37974.4, 37667, 37874.4, 38063.1, 37742.9, 37702.4, 37852.7, 37631.7, 38013.1, 37668.1, 38132, 37303.7, 37953.5, 37201.3, 37260.3, 38000.6, 37450.9, 37587.9, 38046.2, 37852, 37303.6, 37581.5, 37932.7, 37808.2, 37519.6, 37511.6, 37770.8, 37803.6, 37830.3, 37518.7, 37667.7, 37896.2, 37527.7, 37829.7, 37661.1, 37669.6, 37382.1, 37841.1, 37029.7, 37807.3, 37818.6, 37604.8, 38127.6, 37920.9, 37586.4, 37916.2, 38359.7, 38030.5, 38123.8, 37161.7, 37729.7, 37754.2, 37281, 37731.2, 38225, 37663.6, 37601.3, 37568.3, 37277.8, 37398.8, 37740, 37682.7, 37753.5, 37544.6, 37430.2, 37698.4, 37406.5, 37507, 37873.6, 37388.7, 37780.6, 37667.9, 37972.4, 37791.6, 37759.7, 37277.9, 37378.6, 37676.8, 37936.5, 37599.6, 37490.4, 37786.6, 37660.7, 38062.3, 37527.2, 37377.4, 37810.6, 37750.4, 37686.7, 37918.1, 37659.9, 37640.9, 37487.4, 36895.6, 37663, 38215.7, 37541.9, 37835.8, 37674, 38523.4, 38241.4, 37341.5, 37678.7, 37753.4, 37420.7, 38056.2, 37906.8, 37519.1, 37771.2, 37141.5, 37868.7, 37543.9, 37446.8, 37904.8, 37824.1, 37345.8, 37659.1, 37794.1, 37335.7, 37201.8, 37426.7, 37683, 37594.6, 37781.3, 37745.2, 37664, 37484.5, 37820.9, 37225.7, 37662.1, 37405.2, 37514.1, 37702.5, 38109.1, 37604, 37217.7, 37986.7, 37582.6, 37479.6, 37831.4, 37787, 37171.4, 37465.6, 37325.3, 37566.9, 37819.4, 37855.2, 37905.2, 37352.4, 37008.5, 37896.3, 37791, 37851.5, 37337.4, 37759.7, 37844.1, 37633.9, 38210.2, 37729.2, 37418.4, 37592.5, 38014.8, 37659.9, 37589.1, 37520.8, 37560.6, 37714.6, 37616.2, 37357.1, 37420.2, 37726.8, 37506.1, 37237.1, 37772, 38109, 37194.2, 37103.8, 38394.8, 37814.4, 37548.9, 37914.9, 37382.6, 37841.2, 37814.6, 37756.7, 37642.6, 37540.6, 37981.7, 37818.8, 38157.6, 37890.5, 37294.5, 37780.8, 37840.9, 37797.2, 37827.5, 37428.1, 37399.5, 37365.6, 37715.3, 37870.6, 37849.6, 37812.9, 37775.6, 37830.9, 37786.6, 37785.1, 38063, 37871.1, 37271.4, 37621.8, 38417.1, 37617, 37407.4, 37609.1, 37589.8, 37854.7, 37738.1, 37514.1, 37830.9, 37772.6, 38074, 37520.4, 37727.8, 37672.2, 37935.2, 37716, 38052, 38036.3, 37691.7, 37522.7, 37586.7, 38142.7, 37859.2, 37593.7, 37587.9, 37960.2, 37682.3, 37448.6, 37412.2, 37442.9, 38410.1, 38037.6, 37868.3, 37653.4, 37648.6, 38116.2, 38001.6, 37737.3, 37250.8, 37668, 37760.4, 37980.9, 37179.6, 37808.2, 37866.9, 37639.4, 37635.3, 37496.2, 37707.5, 37979.2, 38491.3, 38043, 37123.5, 37619.4, 37678.4, 38131.5, 38159.1, 37937.3, 37609.4, 37650.8, 37786.1, 37993.9, 37826, 37482.2, 37450.1, 38290.7, 38042.3, 37021, 38212.2, 37770.5, 38076.4, 38176.7, 37405.7, 37481.2, 38001.3, 37874, 38070.3, 37972.3, 38358.4, 37654.5, 38082.9, 37308, 37911.9, 37240.6, 37614.3, 37332.2, 37752.2, 37483.8, 37964, 38080.2, 37452.9, 37925.3, 37981, 37959, 37767.7, 37745.6, 37558.4, 37419.8, 38028.9, 37303.9, 37369.3, 37641.8, 37383.4, 37333.8, 37865.9, 37362.6, 37917.3, 37473.2, 37857.2, 37844.6, 37394.8, 37635, 37401.7, 37835.1, 37793.1, 37457.8, 37205.9, 37356.3, 38022.6, 37687.6, 37843.7, 37805.8, 37940.4, 37441.8, 37898.5, 37355.5, 37821.2, 37525.8, 37527.5, 37566.1, 37597.5, 37533.7, 37741.3, 37815.2, 37552.8, 37963, 37882.8, 37359.6, 37346.4, 37304.9, 37610.1, 37916.8, 37284.7, 37243.4, 38040, 37780.6, 36866, 37681.4, 37779.7, 37347.7, 37782.2, 37855.4, 38358.1, 37359.3, 37901.1, 37792.7, 37780.6, 37570.5, 37716.3, 37626.2, 37688.8, 37774.9, 36974.2, 37882.4, 37825.5, 37495.3, 37455.6, 37789.8, 37724.6, 37659.7},{37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719, 37719},{37725.9, 37709.6, 37718.3, 37714.8, 37716.2, 37708.6, 37712.1, 37694.7, 37726.1, 37731.8, 37719.5, 37717, 37725.2, 37712.2, 37724.7, 37708.8, 37718.3, 37721.3, 37715, 37721.2, 37720.6, 37693.9, 37718.3, 37698.8, 37731.8, 37713.3, 37732.3, 37712, 37695.8, 37713.6, 37702.2, 37720.2, 37703.3, 37712.4, 37724.1, 37723.9, 37723.7, 37728.9, 37729.8, 37707.6, 37715.6, 37707.4, 37721.6, 37694.4, 37708.2, 37714.5, 37720.5, 37715.5, 37711.2, 37698.3, 37717.3, 37720.1, 37703.6, 37725.7, 37744, 37717.6, 37722.6, 37728.1, 37717.7, 37720.9, 37712.7, 37700.2, 37708.7, 37720.3, 37729.4, 37697.7, 37710.9, 37710.5, 37716.3, 37715, 37720, 37723.6, 37722.9, 37716.4, 37705.3, 37718.4, 37715, 37708.6, 37717.7, 37700.1, 37722.7, 37719.7, 37723.9, 37717.3, 37722.6, 37718.2, 37727.3, 37726.4, 37720.7, 37707.3, 37701.5, 37715.3, 37715.6, 37702.6, 37724.8, 37717.5, 37739, 37724.1, 37714.7, 37709.9, 37703.4, 37720.3, 37711.2, 37704, 37709.9, 37723.8, 37716.6, 37724.4, 37716.9, 37727.1, 37721.2, 37713.3, 37696.6, 37720.3, 37711.9, 37703, 37723.9, 37720.1, 37713.3, 37707.9, 37712.4, 37718.9, 37720.8, 37718.5, 37706.1, 37726.6, 37713.5, 37699.7, 37716.6, 37717.8, 37715.9, 37721.2, 37730.9, 37710.5, 37723.8, 37722.5, 37718, 37704, 37719, 37718.8, 37712.7, 37738, 37717.2, 37717.2, 37704.5, 37714.1, 37713, 37716.1, 37726.7, 37704, 37706.5, 37707.5, 37727.6, 37721.4, 37700, 37717.4, 37726.4, 37718.6, 37713.7, 37717.7, 37720.2, 37718.6, 37715.9, 37710.3, 37714.2, 37717.4, 37708.7, 37722, 37720, 37709.6, 37723.1, 37715.3, 37718.8, 37716.8, 37718.8, 37723.2, 37715.7, 37721.5, 37704.4, 37720.2, 37724.1, 37724, 37724.6, 37712.9, 37702, 37716.7, 37724.1, 37724.2, 37727.3, 37717.1, 37716.3, 37717.9, 37718.9, 37714, 37718.3, 37707.7, 37709.3, 37721.1, 37725.2, 37706.5, 37710.9, 37720.8, 37716.4, 37717.5, 37696.9, 37725.5, 37722.9, 37716.7, 37715.1, 37710.1, 37714.9, 37715.2, 37713.9, 37731.5, 37711.8, 37708.4, 37719.6, 37717.7, 37719.7, 37694.8, 37723.6, 37705.3, 37741.1, 37716.9, 37716.9, 37706.9, 37717.5, 37718.1, 37719.4, 37714.9, 37716.3, 37707, 37711.3, 37708.8, 37724.1, 37740.5, 37717.4, 37717.4, 37717.8, 37714.6, 37711.7, 37710.9, 37693.3, 37704.3, 37717.1, 37718.5, 37698.8, 37721.8, 37716.6, 37706.8, 37719.5, 37711.5, 37715.8, 37710.1, 37694.7, 37717.7, 37733.9, 37719.7, 37726, 37707, 37706, 37722.2, 37721.9, 37720.6, 37722.1, 37717, 37723.7, 37724.4, 37716, 37717.8, 37719, 37742.5, 37735.9, 37711.3, 37732.9, 37724.2, 37722.6, 37707.7, 37715.3, 37713.3, 37735.7, 37719.1, 37713.5, 37722.6, 37721.8, 37709.6, 37733.4, 37700.7, 37714.9, 37708.9, 37717.2, 37722.8, 37714, 37728.5, 37717.3, 37714.3, 37713.9, 37720.1, 37717.4, 37703.3, 37720.4, 37719.7, 37721, 37716.2, 37717, 37722.8, 37706.4, 37717.9, 37717.4, 37715.2, 37715.2, 37729.4, 37705.9, 37715.1, 37721.6, 37719.3, 37703.2, 37718.7, 37709.3, 37717, 37717.6, 37710.4, 37706.1, 37722.9, 37726.1, 37703.6, 37709.2, 37708.8, 37717.9, 37734, 37711.9, 37702.2, 37709.6, 37722.4, 37723.9, 37703, 37703.8, 37706.1, 37712.3, 37711.2, 37723.5, 37715.1, 37720.2, 37731, 37705.8, 37726.8, 37714, 37714.3, 37720.5, 37717.2, 37718.8, 37719.3, 37724.3, 37715.5, 37709, 37725.5, 37710.1, 37712.8, 37705, 37716.9, 37714.5, 37708, 37707.2, 37706.8, 37723.7, 37704.9, 37718.9, 37741.4, 37713.1, 37721.8, 37719.1, 37715.2, 37695.6, 37711.7, 37695.6, 37721.2, 37726.2, 37714.6, 37713.3, 37725, 37702.2, 37726.2, 37732.7, 37715.9, 37721.7, 37720.4, 37713.6, 37712.2, 37716.9, 37711.2, 37714.1, 37731.9, 37717, 37712.2, 37701.6, 37721.4, 37723, 37715.8, 37714.4, 37715.6, 37722.8, 37712.2, 37710.9, 37719.3, 37723.5, 37703.9, 37722.6, 37759.3, 37713.4, 37719.2, 37710.3, 37718.6, 37719.7, 37709.3, 37722.2, 37699.8, 37716.5, 37716.5, 37718, 37711.1, 37721.9, 37724.3, 37716.6, 37722.6, 37725, 37702.8, 37716, 37725.2, 37711.8, 37712.5, 37708.4, 37711.8, 37708.6, 37720.6, 37719.1, 37715.1, 37718.9, 37715.9, 37712, 37718.7, 37720.3, 37713.1, 37717.6, 37718.6, 37722.3, 37719.1, 37723.4, 37702.6, 37714, 37713.6, 37698, 37706, 37715.8, 37714.3, 37700, 37699.2, 37715.4, 37722, 37706, 37716.8, 37714.3, 37708, 37710.5, 37727.3, 37706.8, 37721.6, 37724.7, 37715.1, 37693.7, 37730.1, 37724.2, 37697.6, 37713.3, 37707, 37701.5, 37721.5, 37728, 37725.1, 37711.9, 37718.7, 37704.6, 37703.4, 37708.7, 37708, 37713.7, 37708.7, 37700.9, 37727.5, 37716.4, 37727, 37721.9, 37706.8, 37715.4, 37721, 37725.1, 37715.9, 37702.4, 37711.1, 37722.6, 37726.8, 37710.8, 37716.9, 37729.1, 37718.2, 37725.6, 37732.7, 37734.4, 37719.7, 37716.2, 37704.7, 37727.3, 37720.6, 37715.1, 37741.7, 37711.6, 37700.8, 37700.1, 37725.7, 37697.9, 37700.5, 37722.6, 37716, 37722.4, 37722, 37727, 37702.5, 37720.8, 37709.6, 37705.7, 37716.2, 37714.1, 37718.9, 37720.8, 37724.1, 37708.7, 37720.5, 37703.7, 37713.9, 37718.4, 37729.2, 37730.7, 37717.1, 37725.8, 37696.7, 37715.4, 37705.6, 37716.9, 37720.6, 37705.4, 37731.4, 37709.2, 37717, 37717.1, 37719.9, 37721.7, 37717.2, 37727.7, 37719.5, 37718.3, 37711.3, 37724.6, 37708.1, 37714.3, 37715.3, 37719.9, 37718, 37714.9, 37719.2, 37718.8, 37719.8, 37712.2, 37706, 37699.9, 37714.8, 37714.7, 37721.8, 37729.8, 37708.8, 37724.7, 37720.1, 37701.8, 37718.7, 37710.4, 37705.1, 37719.4, 37709.3, 37719.5, 37702.9, 37717.7, 37729.4, 37705, 37708.8, 37726.7, 37720.7, 37693.3, 37712.1, 37709.9, 37724.5, 37714.5, 37713.6, 37710.1, 37717.9, 37718.3, 37722.5, 37719.7, 37703, 37704.5, 37700.3, 37705.6, 37721.8, 37712.1, 37710.1, 37713.1, 37719.4, 37720.5, 37728.6, 37718.2, 37714.6, 37719, 37724.4, 37743.7, 37696.8, 37714.7, 37727, 37717.7, 37715.3, 37711.9, 37714.3, 37723.5, 37719.2, 37720.2, 37721.6, 37718.9, 37703.3, 37721.7, 37720.4, 37704.7, 37712.9, 37704.9, 37704.6, 37725.6, 37700.8, 37712.8, 37705.6, 37716.6, 37706.3, 37733.1, 37716.6, 37726.4, 37722.9, 37721.3, 37718.7, 37711.3, 37721.1, 37711.2, 37693.5, 37715, 37711.3, 37720.7, 37710.8, 37705.6, 37725.3, 37725.8, 37710.6, 37716.1, 37722.7, 37728.3, 37703.7, 37723.3, 37706.5, 37726.5, 37707, 37776.9, 37718.8, 37709.4, 37717.7, 37725.2, 37718.3, 37718.7, 37696.7, 37706.3, 37712.3, 37714, 37717.3, 37710.4, 37716.3, 37723, 37717.4, 37726, 37714.2, 37719.8, 37712.5, 37734.5, 37706.4, 37708.9, 37726.8, 37720, 37720.2, 37717.8, 37703.3, 37723.1, 37710.7, 37725.3, 37713.4, 37708.6, 37719.4, 37699.6, 37716.4, 37713.2, 37705.7, 37702.2, 37713.3, 37718.4, 37715.8, 37701, 37731.3, 37715.2, 37713.3, 37704.3, 37702.8, 37703.7, 37710.3, 37705.4, 37706.1, 37712.3, 37716.2, 37726.3, 37718.4, 37722.8, 37709.7, 37709.4, 37705, 37716, 37710.5, 37740.9, 37717.4, 37695.9, 37725.5, 37713.3, 37713.9, 37724, 37719.4, 37718.5, 37694.8, 37731.9, 37724.6, 37704.5, 37717.1, 37716.6, 37715.3, 37720.9, 37713.1, 37720.4, 37708.6, 37721.3, 37717.8, 37718.5, 37723.5, 37721.4, 37722.7, 37715.4, 37710.7, 37726.7, 37695.5, 37715.4, 37706, 37724.5, 37711, 37719, 37695.5, 37717.9, 37696.3, 37719.1, 37720.4, 37700.3, 37718.3, 37720.3, 37722.2, 37716.4, 37711.3, 37715.2, 37739.6, 37700.3, 37713.4, 37700.1, 37709.2, 37702.9, 37716, 37699.1, 37704.8, 37714.6, 37725.7, 37712.8, 37704.1, 37715.1, 37711.1, 37710.3, 37714.3, 37697.6, 37719.7, 37720.7, 37717.4, 37696.2, 37717.8, 37716.7, 37711.4, 37711, 37735.8, 37708, 37718.8, 37723.1, 37712.8, 37721.1, 37715, 37730.1, 37706.8, 37724.1, 37722, 37724.7, 37721.7, 37701.8, 37702.6, 37732.6, 37705.4, 37703.8, 37715.3, 37711.1, 37711.3, 37708.4, 37720.4, 37721.9, 37706.5, 37711.7, 37712.6, 37711.2, 37715, 37726, 37706.7, 37714.8, 37722, 37700.6, 37717.2, 37718.9, 37719.7, 37714.4, 37715, 37719.2, 37715.2, 37715, 37720.1, 37721.6, 37719.8, 37713.6, 37732.1, 37715.7, 37713.1, 37720, 37731.2, 37723.8, 37704.6, 37693.7, 37716.8, 37714.4, 37719.9, 37715.9, 37713.3, 37725, 37724.3, 37721.7, 37721.4, 37711.3, 37715.9, 37728.5, 37713.3, 37717.1, 37700.5, 37721.1, 37722.3, 37719, 37721.6, 37726.7, 37695.7, 37704.4, 37701.3, 37715.6, 37720.9, 37711.8, 37708.6, 37717.2, 37703.6, 37710.4, 37713.8, 37706.3, 37719.2, 37704.5, 37709.1, 37719.5, 37727.6, 37716.5, 37723.9, 37723.3, 37713.9, 37721, 37708.3, 37710.5, 37713.2, 37721.5, 37721.5, 37707.4, 37730, 37725.2, 37725.6, 37716.2, 37714.7, 37702.9, 37721.5, 37721.2, 37720.6, 37728.2, 37719.4, 37724.6, 37724.8, 37733.6, 37719.3, 37717.4, 37721.4, 37704.7, 37719.2, 37725, 37714.2, 37713.7, 37722.1, 37709.7, 37710.3, 37722.5, 37730.3, 37717.9, 37713.4, 37723.9, 37701.9, 37715.5, 37709.2, 37712.5, 37707.9, 37708.8, 37723.5, 37721.9, 37716.3, 37711, 37703.8, 37705.9, 37725.1, 37720.8, 37714.3, 37711.1, 37719.7, 37721.8, 37723.3, 37713.9, 37715.5, 37710.2, 37714.1, 37729.7, 37699.6, 37715.6, 37732.8, 37717, 37715.6, 37710.3, 37742.4, 37716.1, 37706, 37710, 37720.2, 37709.1, 37709.8, 37700.9, 37713.6, 37711.2, 37710.6, 37697.7, 37708.1, 37719.6, 37717.1, 37710.7, 37694, 37728.1, 37721.5, 37715.5, 37727.6, 37706.4, 37734.9, 37700.8, 37712.7, 37726.2, 37721.4, 37720.6, 37716.5, 37717.7, 37741.6},{38786.6, 38705.9, 37695.7, 34901.2, 35895.2, 36394.8, 36905.7, 36253.3, 41296.1, 36260.6, 38098.1, 36730.3, 37685.3, 35215.7, 40179.9, 35056.4, 35610.9, 38547.1, 36159.3, 34075.9, 38278.5, 36691.8, 37645.6, 34930.4, 34469.6, 36670.5, 37084.7, 36839, 36132.9, 33475.4, 35603.6, 40053.3, 36276.7, 36973.9, 34648.1, 40388.1, 36672, 36493.2, 38614.6, 36631.8, 38099.7, 35846.6, 37400.1, 36381.7, 37303.5, 38762.2, 36540.5, 35109.8, 37499.8, 36676.3, 35638.9, 38308.6, 37652.3, 36795.6, 39606.6, 39308.3, 35794.9, 36242.5, 36106.5, 36125.1, 40358.2, 38431.5, 36780, 37325, 37755.9, 37396.9, 37900.8, 37889.5, 40148.9, 36510.5, 40892.2, 39248, 36848.3, 39447.4, 40833.9, 35283.7, 38218.6, 39513.4, 37051.2, 39638.4, 33783.4, 39245.2, 40603, 40771.3, 33923, 38320.9, 40165.2, 37963.8, 40991.7, 37265.4, 35493, 36571.6, 36464.1, 36162.9, 37988.6, 40887.6, 38630.8, 34874.5, 36627.8, 33895.6, 37743.6, 40374.7, 35280.4, 37581, 35650.7, 35330.7, 37329.1, 37856.7, 36732.1, 35017.4, 35539, 40310.6, 37020, 39353.5, 37476, 36777.1, 34783.1, 38494.6, 34732.7, 37327.3, 37200.1, 38442.7, 42325.7, 35310.9, 36903.1, 37654.5, 40441.2, 36461.1, 34655.6, 35798.9, 39930.8, 37164.2, 34424.6, 34678.9, 39909.9, 35657.8, 36310, 37628.5, 36688.3, 37409.9, 36736.7, 35159.7, 38347.2, 37484.1, 39188.9, 38667.5, 38433.4, 35056.6, 36859.9, 31867.1, 38112.1, 36518.7, 38251.4, 34789, 38898.6, 37638.8, 38628.6, 39652, 37534.7, 35843.6, 36681.7, 35862, 39376.3, 37030.8, 38793.7, 37849.4, 31047.1, 36069.8, 36872.8, 34120.1, 34659.7, 36492.2, 38872.7, 36800.5, 37479.7, 39129.2, 34379, 40784.4, 37299.1, 37906.9, 36778.8, 38566.7, 37690.7, 38012, 35544.8, 36833.2, 38934.5, 41656.8, 39322.4, 38174.5, 38284.4, 37517.8, 40587.4, 36742.3, 42682.1, 38217.2, 39608.8, 38421.7, 37202.1, 38002.9, 37330.3, 37869.5, 38610.8, 38538.1, 37759.9, 39145.3, 35922.5, 39553.1, 37475.3, 35544.7, 38708.3, 37391.4, 35862.4, 38326.4, 38902.1, 38634.4, 36815.3, 37464.7, 36545.9, 36529.6, 37498.8, 36214.5, 36934.9, 37821, 42148.6, 35468.9, 36771.8, 32000.4, 36255.9, 39776.3, 38678.6, 39411.5, 37252.8, 35097, 39529.9, 37083.1, 39891.3, 38995.2, 38437.3, 36921.5, 34413.4, 38748.3, 35473.7, 35873, 37316, 37953.7, 38290.4, 37706.1, 35160.3, 37142.1, 39826.6, 38607.9, 37733.9, 36342.2, 37750.1, 40429.2, 35978.9, 39234.4, 37998.7, 34194.6, 37220.7, 38629.7, 38811.9, 37888.8, 37927.5, 36587.2, 37590.9, 39393.7, 39898.9, 33321.2, 35902.3, 37921.6, 32502.4, 41320.6, 37730.7, 39942, 36960.8, 39611.6, 39770.9, 36400.4, 40474.8, 35895, 37227.5, 37883.9, 35585.3, 38507.5, 38582.8, 38568.5, 38266.2, 39455.5, 38671.6, 37523.4, 37365, 37284.5, 38247, 37179.1, 37612.4, 38709.9, 38130.6, 36002.3, 36099.2, 36297.4, 38444.4, 39754.6, 37186.7, 36129.6, 40355.3, 37813.1, 37100.3, 39430.5, 38367.5, 38551.6, 38283.9, 35893.2, 34809.3, 38756.9, 38427.7, 36598.5, 37070.2, 34361.9, 33568.9, 37092.7, 36749.2, 39124.3, 37052.5, 35218.7, 34924.3, 35908.4, 32958.7, 39468.3, 35945.8, 37674.8, 40997, 36188, 39868.7, 40198.1, 35695.3, 38411, 36491.2, 34835.6, 37921.7, 40075.1, 38508.6, 38446.1, 40563.3, 36662.2, 36626, 37313.2, 40830.5, 41617.6, 37126, 34889.8, 34531.2, 38484.3, 40652.7, 38633.6, 37305.1, 37399.5, 35968.1, 35118.1, 36953.7, 38269.7, 38998, 36320.5, 37847.7, 33628.3, 32458.1, 36107.8, 39658.9, 34871, 40023.6, 34831.9, 38804.7, 37317.2, 36093, 38012.5, 36499.9, 39230, 39508.9, 37631.4, 35592.4, 36900.8, 35805.2, 37694.6, 37557.2, 39144.2, 38624.6, 34778.4, 36005.6, 37440.4, 37870.9, 36553.2, 36115, 42229.7, 38665.4, 34593, 39136.7, 33398.7, 35678, 37475.9, 36669.5, 37004.8, 36717.1, 36765.3, 35486.5, 37147.6, 34353.5, 35967.7, 38149.1, 35724, 32167.2, 36305.1, 35869.2, 37052.7, 39146.6, 34993.3, 37398.2, 35109.6, 36946.5, 38050.5, 35502.7, 39782.6, 36330.1, 38036.5, 37880.7, 34787.1, 37693, 38927.8, 34765.3, 32202.5, 36717.5, 38437.5, 39212.2, 39467.2, 37075.6, 38305.2, 38582.8, 38783.8, 35670.7, 35624, 37600.1, 37513, 38573.7, 35822.1, 37303.4, 38584, 36976.2, 35432.8, 39027.2, 34986.7, 36958.8, 38309.4, 37799.6, 38490.4, 36424.5, 36647.2, 36622.7, 37734.2, 39649.2, 36982.6, 37157.9, 38272.4, 36377.8, 39608.4, 32884, 38638.8, 36918.5, 38649.7, 37149.9, 36390.3, 35252.4, 38753, 38965.9, 35672.9, 40375.5, 38846, 37544.9, 38380.7, 40865.5, 36886.4, 40465.4, 37352.8, 38331.4, 38072, 36192.7, 37088.3, 35583.5, 39944.2, 38242.2, 39303.8, 36576.7, 36991.9, 39177.6, 41792.4, 37210.4, 35636.6, 40637.3, 35588.2, 37719.6, 40587.4, 39041.6, 38477.7, 35659.2, 39744.5, 34354.1, 35772.4, 38197.4, 34698.5, 37259.5, 35159.6, 36868.4, 33662.8, 41201.6, 35233.3, 36373.6, 36199.8, 38705.2, 36347.4, 39733.1, 37711.4, 34431.8, 36624.8, 39098.3, 38836.9, 41366.1, 35134.9, 39155.2, 35926.9, 38251.7, 38246.7, 37144.1, 37033.4, 34622.7, 36866.4, 38555.6, 36851.6, 36973.3, 37812.8, 38742.9, 37905, 38197, 37001.4, 38274.3, 40878.4, 36865, 34923.4, 37311.8, 37636.6, 36812.3, 36346, 34875.2, 37044.7, 36260.4, 34959, 39015.1, 39447.5, 38111.8, 36926.8, 34523.8, 38362.5, 39508.8, 35455.1, 38645.2, 39050.6, 36315.8, 39368.5, 37787.6, 39219.5, 37875.6, 35592.5, 39239.2, 37185.4, 39013, 37614.8, 37133.7, 40285.4, 36170.9, 38319.2, 35461.7, 37494.9, 38421.1, 36486.8, 36726.7, 35354.2, 36703.5, 42498.8, 39295.3, 40509.3, 37433.9, 34603.1, 39718.3, 41643.3, 38220.1, 35358.6, 34397.8, 37887.2, 36764.5, 33956.9, 40313.4, 36577.7, 39007.8, 36434.8, 35235.9, 35722.7, 38985.9, 35610.1, 35697.9, 34960.5, 36872.8, 38604.2, 39001.4, 40229.2, 36961, 39065.3, 38417.8, 38948.7, 34424.8, 37172.9, 40438.3, 42704.8, 37894.9, 39805.1, 38802.8, 36389.7, 36870.8, 38513.2, 38782.7, 39468.5, 35797.7, 35620.4, 38593.8, 37093.6, 37269.8, 36929.9, 35458.6, 38096.5, 35396, 34958.1, 40804.6, 40158.9, 37802.4, 35614.5, 36504.2, 36422.3, 39466.6, 38198.9, 33839.6, 39769, 35129.4, 39087.6, 35878.4, 36702.5, 36684.9, 39436.5, 33270.2, 36949.8, 37313.1, 38167.7, 39562.5, 36620.6, 38138.6, 35836.4, 36794.3, 35371.5, 38277.8, 35970.4, 36982.5, 33679.9, 41291.3, 33357.2, 37979.4, 35873.7, 33264.2, 36971.1, 35432.8, 34989.4, 39415.1, 37852.6, 35713.8, 38702.3, 37658.1, 38609.2, 41107.9, 39975.9, 41944.3, 35127.5, 37580.1, 35800.6, 37877.7, 33974.9, 35190.7, 39643.4, 39000.6, 37609.1, 35800.8, 37468.8, 35216.7, 36744.7, 36308.9, 35433, 38122, 35202.2, 38304.1, 39974.6, 39291.4, 34742.5, 38723.2, 35692.8, 36560.7, 35442.8, 35847.6, 37057.9, 38464.2, 37927.7, 40101.2, 39456.2, 36217.9, 37633.3, 38270.5, 37937.9, 34545, 34232.3, 36559.1, 37591.8, 40608.1, 37286.2, 38794, 36237.9, 38079.9, 39796.7, 40173.6, 36889.8, 35176, 38594.4, 37527.4, 40136.5, 38570.9, 33944.3, 40313, 38420.3, 38981.1, 37026.3, 37988.9, 38442.8, 37265.5, 35618.7, 33520, 38965.7, 36226.3, 36886.9, 37182.3, 39466.4, 37422.8, 37369.3, 36584.9, 38736, 36349.8, 35374.7, 39016, 38569.3, 39237.4, 31921.1, 35136.8, 38601.3, 39386.9, 37450.4, 36578.6, 37296.4, 38209.1, 36517.6, 36405.4, 38038.4, 37877.6, 37325.3, 38281.6, 38087.2, 36356.5, 34292.3, 37327, 35459.7, 35857.6, 34948.2, 36656.2, 36818.9, 37992.8, 38815.7, 39496.9, 35271.6, 39138.8, 36732.5, 37633.1, 34671.9, 38611.5, 42128.8, 37572.7, 35146.5, 36558.5, 38405.2, 38767.3, 37728.6, 38266.7, 39591.7, 34594.3, 35974.6, 37160, 41029.2, 34992.3, 37401.7, 34739, 37008.6, 37566.4, 38615, 39042.4, 36669.8, 36438.2, 34058.3, 37173.8, 37043, 37748.1, 37651.6, 40261, 36268.4, 38861.3, 39408.5, 38839, 37601.1, 34489.8, 37109.4, 35040.7, 34779.1, 35344.5, 36622.9, 34497.1, 38121.9, 36062.6, 37888.3, 39662.8, 36273.1, 35927.9, 40054.2, 38476.7, 35489.5, 36764.7, 37803.1, 36833.4, 38086.6, 41643.6, 35484.9, 36953.8, 36014.4, 40044.7, 37027.7, 36361.8, 37811.8, 40616.3, 37781, 36423.5, 39580.7, 39416.2, 37491.3, 36692.7, 37496.8, 37835.8, 37415.2, 39059.9, 39627.4, 35023.1, 38647.9, 37955.7, 35869.9, 39365.5, 35119.8, 37048.6, 37041.5, 37274.2, 39693.4, 36937.3, 36561.5, 38641.5, 40825.8, 37441.9, 36231.1, 39241.6, 37429.6, 40029.3, 38649.9, 36642.2, 37645.2, 40160, 34734, 40224.6, 37137.1, 37870.9, 38730.7, 39476.3, 38666.2, 37755.1, 37303.5, 36051.1, 37505.9, 36478.5, 34099.2, 38254.9, 39702, 35852.3, 37854.5, 38790.2, 38529.7, 39598.5, 42191.9, 38742.3, 36002.2, 37943.8, 38558.7, 37253.4, 38861.6, 39855.8, 34396.9, 34971.4, 36603.3, 37966.3, 36566.9, 36737.3, 37147.7, 35137.5, 35907.6, 36492.3, 38875.5, 35360.5, 38325.5, 37913, 37189.3, 38438.5, 34881.2, 38598.4, 37387.8, 35222.4, 34530.5, 38925.2, 37989.4, 36605.8, 37139.3, 36350.5, 36473.9, 36071.8, 37589.4, 36817.3, 37744.1, 40202.8, 36360.5, 38124.4, 36536.1, 31807.6, 33293.3, 36486.2, 37583.7, 36713.7, 32560.5, 39731.6, 39663.6, 37845.3, 36348.5, 38657.9, 36205.7, 35207.8, 37696.4, 38685.7, 37898.1, 36421.6, 35541.5, 37351, 36649.2, 38019.3, 37497.4, 41053.8, 37087.9, 37059.2, 37422.8, 38363.6, 38141.6, 37884.7, 34759.4, 38113.9, 38299.4, 37054.4, 40768.2, 34507.8, 37762.9, 36577.7, 35220.4, 37517.7, 34876.6, 38712.3, 33337.9, 36870.8, 34197.1, 37504.2, 37016.4, 40438.1, 37941.3},{37717.9, 37718.8, 37717.2, 37719.8, 37717.7, 37718.2, 37718.9, 37718.2, 37717.3, 37717.2, 37718.6, 37720.1, 37718.6, 37717.9, 37717.9, 37717.5, 37718.4, 37719.4, 37718.6, 37718, 37718.7, 37717.1, 37718.4, 37717.7, 37718.5, 37718.4, 37717.5, 37717.6, 37718.5, 37718.9, 37718.6, 37717.7, 37718.2, 37718.6, 37718.6, 37718.8, 37718.4, 37717.5, 37719.3, 37719.6, 37717.7, 37718.1, 37718.1, 37718.3, 37718.3, 37717.7, 37718.3, 37718.7, 37719, 37718.2, 37717.9, 37718.3, 37718.5, 37718.1, 37717.5, 37719.1, 37718.4, 37718.4, 37718.5, 37717.5, 37718.4, 37716.6, 37717.2, 37718.8, 37718.6, 37719.2, 37719.5, 37718.3, 37719.4, 37717.7, 37718.9, 37717.9, 37718.1, 37719.3, 37717, 37718.6, 37717.7, 37719.2, 37717.3, 37718.9, 37718.1, 37717.8, 37718, 37719.1, 37717.5, 37718, 37717.9, 37718.8, 37718.1, 37718.3, 37719.5, 37717.2, 37717.4, 37718.9, 37718.4, 37719, 37718.4, 37718.3, 37719, 37718.1, 37717.6, 37718.7, 37717.6, 37720.5, 37718.2, 37718.4, 37718.3, 37718.2, 37717.6, 37718.2, 37720.1, 37718.9, 37719, 37719, 37718.3, 37718.6, 37717.9, 37718.4, 37717.5, 37718.3, 37717.4, 37718.3, 37717.3, 37718.9, 37717.2, 37716.6, 37718.1, 37718.3, 37719.6, 37718.5, 37718.1, 37717.9, 37718.5, 37718.4, 37717.6, 37718.2, 37718.5, 37717.9, 37717.8, 37718, 37718.3, 37718.5, 37717.7, 37718.1, 37717.9, 37718.6, 37717.9, 37717.6, 37718.8, 37718.4, 37718.5, 37718.2, 37717.4, 37718.3, 37717.8, 37719, 37717.8, 37718.3, 37719.4, 37718, 37717.2, 37718, 37719, 37718, 37719.5, 37719.2, 37718.1, 37717.9, 37717.3, 37718.5, 37718.9, 37718.6, 37718.9, 37719.5, 37718.2, 37717.5, 37717.8, 37718.3, 37717.7, 37719.6, 37718.1, 37718.7, 37718.4, 37718.5, 37717.8, 37718.9, 37717.8, 37719.1, 37718.2, 37718.8, 37719.1, 37718.5, 37718, 37718.1, 37718.5, 37718.4, 37717.5, 37718.9, 37719.6, 37718.2, 37717.8, 37718.5, 37717.1, 37719.6, 37717.7, 37718, 37717.9, 37718.6, 37718.3, 37718.1, 37718.5, 37718.4, 37718.1, 37717.8, 37718.7, 37717.6, 37717, 37717.3, 37719.2, 37717.1, 37718.2, 37718.6, 37718.8, 37717.6, 37718.3, 37718.3, 37718.3, 37719.2, 37718.2, 37719.1, 37717.5, 37718.5, 37718.3, 37719.2, 37718.2, 37718.7, 37718.1, 37718.1, 37717.9, 37719.1, 37719, 37717.9, 37718.5, 37717.9, 37716.8, 37718.1, 37717.9, 37718.6, 37718.3, 37717.7, 37718.2, 37720.4, 37718.7, 37718.3, 37718.8, 37718.6, 37719.2, 37719.1, 37718.4, 37717.8, 37718.2, 37718, 37717.8, 37718.6, 37718.7, 37717.5, 37719, 37717.9, 37719.2, 37719.3, 37718, 37718.4, 37719.2, 37718.8, 37717.5, 37718.5, 37717.8, 37718.3, 37717.7, 37718.4, 37718.3, 37717.1, 37718.4, 37718.7, 37717.6, 37716.6, 37719.4, 37718.2, 37718.6, 37717.7, 37717.7, 37717.7, 37718.8, 37717.8, 37718.7, 37717.9, 37718.1, 37717.9, 37719, 37719, 37718, 37718.5, 37717.9, 37718.9, 37718.2, 37718.5, 37717.9, 37718.9, 37719, 37718.5, 37717.9, 37718.9, 37717.5, 37718.9, 37717.8, 37718.1, 37719.6, 37718.8, 37717.9, 37718.9, 37716.9, 37718.6, 37719.8, 37717.7, 37718.1, 37718.8, 37718.7, 37717.9, 37717.8, 37719.7, 37717.8, 37717.9, 37718.4, 37718.5, 37717.8, 37717.4, 37718.3, 37718.3, 37718.3, 37718.5, 37716.9, 37717.9, 37718.4, 37719.1, 37718.6, 37717.7, 37718.2, 37718, 37717.6, 37718.1, 37719.3, 37720, 37720.3, 37717.2, 37717.2, 37716.4, 37717.6, 37718.1, 37719.5, 37717.4, 37717.8, 37718.2, 37718.2, 37717.3, 37718.6, 37719.5, 37718, 37718, 37718.8, 37718.4, 37718.2, 37718.7, 37718, 37717.6, 37720.4, 37717.9, 37718.9, 37717.8, 37719.5, 37719.1, 37718.8, 37718.1, 37718.1, 37718.5, 37717.2, 37718.2, 37718.2, 37717.5, 37717.9, 37718.5, 37720, 37720, 37718.2, 37718.2, 37719.5, 37719.4, 37719, 37717.3, 37717, 37718.7, 37719.5, 37717.9, 37718.4, 37718.8, 37719, 37719.1, 37718, 37719.2, 37718.7, 37718.6, 37719.8, 37718.6, 37718.3, 37717.9, 37718.1, 37718, 37720, 37717, 37718.6, 37718.3, 37718.5, 37718.4, 37717.6, 37718.8, 37719.1, 37718.1, 37718.2, 37718.9, 37719, 37716.8, 37718.7, 37717.7, 37717.4, 37717.8, 37718, 37719.8, 37718.2, 37718.4, 37717.7, 37719, 37718.1, 37718.2, 37717.3, 37717, 37718.7, 37717.8, 37717.8, 37719.1, 37717.8, 37720.6, 37718.9, 37718.3, 37718.3, 37718.8, 37719.2, 37717.1, 37717.9, 37719.1, 37718.5, 37717.6, 37719, 37719.1, 37719.5, 37719.2, 37718, 37716.9, 37718, 37717.5, 37718.9, 37718.6, 37719.2, 37718.8, 37717.8, 37718.6, 37718.6, 37717.8, 37718.8, 37718.2, 37718.3, 37718.9, 37717.7, 37720.2, 37717.5, 37717.2, 37718.9, 37719.9, 37719.5, 37718.6, 37718.5, 37719.4, 37718.6, 37718.8, 37718.3, 37718, 37717.4, 37719.2, 37717.9, 37717.7, 37719.3, 37717.1, 37719.3, 37717.7, 37717.7, 37718, 37718.5, 37719.9, 37718.3, 37719.5, 37718.8, 37718.1, 37718.7, 37718.2, 37717.5, 37718.4, 37718.4, 37719.1, 37718.5, 37717.7, 37718, 37717.7, 37717.9, 37719.9, 37718, 37717.4, 37717.9, 37719.1, 37717.7, 37717.9, 37718.3, 37719.1, 37719.2, 37718.8, 37717.2, 37717.8, 37718.4, 37717.9, 37719.5, 37719.3, 37718, 37719.2, 37717.5, 37716.6, 37717.1, 37719.2, 37718.5, 37717.8, 37718.6, 37718.6, 37718.1, 37718, 37718.8, 37718.1, 37717.3, 37719.9, 37718.8, 37718.1, 37718.2, 37719.3, 37718, 37719.3, 37718, 37717.9, 37718, 37718.4, 37719.3, 37718.1, 37717.9, 37718, 37717.5, 37717.5, 37719.2, 37718.1, 37718.2, 37718.5, 37718.6, 37718.9, 37718.3, 37717, 37718.7, 37718.5, 37719.5, 37718.4, 37718.4, 37717.7, 37718.4, 37718.1, 37718.4, 37717.8, 37718.1, 37717.5, 37719.1, 37717.4, 37719.4, 37718.2, 37717.8, 37718.9, 37717.4, 37718.7, 37719.7, 37719, 37717.5, 37717.8, 37717.3, 37719.9, 37718.5, 37717, 37717.1, 37718, 37718.6, 37719, 37719.1, 37718, 37717.6, 37718.3, 37718.9, 37718.2, 37719, 37718.7, 37717.5, 37718.1, 37717.6, 37718.3, 37719.1, 37717.3, 37717.4, 37717.6, 37718.6, 37718.7, 37718.7, 37717.3, 37717.7, 37718.6, 37717.3, 37718.8, 37718, 37718.9, 37718.2, 37719.5, 37718.9, 37718.6, 37717.9, 37719.2, 37718.4, 37719.1, 37717.9, 37718.8, 37718, 37717.4, 37718, 37718.8, 37719.6, 37716.9, 37719.5, 37718.6, 37718.5, 37717.5, 37718.6, 37718, 37718.3, 37718.3, 37718.3, 37717.8, 37718.4, 37717.8, 37717.3, 37717.8, 37718.6, 37717.1, 37718.4, 37719.3, 37718.2, 37718.8, 37717.7, 37718.3, 37718.7, 37719.3, 37718.9, 37718.5, 37718, 37718.5, 37717.7, 37719, 37717.4, 37717.4, 37718, 37717.7, 37718.1, 37717.7, 37718.8, 37718.1, 37718.8, 37718.2, 37718.9, 37718.2, 37717.5, 37719.3, 37717.9, 37718.7, 37720, 37717.7, 37718.4, 37718.4, 37718.8, 37718.7, 37718, 37717.7, 37718.5, 37718.3, 37718.5, 37719, 37718.3, 37718.7, 37717.6, 37718.6, 37718.9, 37718.8, 37717.3, 37718.6, 37718.1, 37718.6, 37718.6, 37719, 37718.8, 37718.5, 37717.3, 37718.3, 37718.2, 37717.5, 37718.1, 37718.5, 37720.6, 37718.2, 37718.5, 37717.4, 37718.1, 37719.3, 37718.1, 37718, 37719, 37717.2, 37717.8, 37719.5, 37718.7, 37717.9, 37717.8, 37717.9, 37718.7, 37718.1, 37719, 37719.2, 37717.6, 37718.3, 37719, 37717.6, 37717.6, 37718.7, 37719, 37717, 37718.6, 37718.6, 37718.4, 37716.8, 37717.2, 37718.3, 37720, 37719.1, 37718.2, 37719, 37719.9, 37718, 37721.1, 37718.8, 37719, 37717.7, 37717.9, 37718.6, 37719.3, 37718.2, 37718.8, 37718.5, 37719.1, 37717.3, 37718.7, 37718.5, 37717.8, 37719, 37719, 37719.7, 37718.8, 37718.9, 37718.1, 37718.7, 37718.4, 37718.6, 37717.5, 37718.1, 37718.8, 37717, 37718.9, 37718.6, 37717.4, 37718.8, 37717.3, 37717.7, 37718.8, 37717.9, 37717.8, 37719.4, 37719.3, 37718.1, 37717.4, 37717.6, 37718.6, 37718.8, 37718.4, 37717.9, 37718.8, 37718.6, 37718.2, 37718.6, 37718.4, 37717.5, 37718.2, 37718.4, 37719.9, 37718.2, 37719.1, 37718.5, 37718.3, 37718.2, 37718.8, 37717.9, 37718.2, 37718, 37717.4, 37718.5, 37717.1, 37719.4, 37717.8, 37719.6, 37718, 37719.6, 37718.6, 37718, 37717.4, 37718.2, 37718, 37718.1, 37718.7, 37718.5, 37717.7, 37717.8, 37718, 37717.9, 37718.7, 37718.4, 37719.1, 37717.6, 37718.2, 37717.8, 37719, 37718.4, 37718, 37718.6, 37718.5, 37718.4, 37717.5, 37718.8, 37718.5, 37718.3, 37719, 37719.4, 37718.4, 37719.5, 37718.4, 37718.1, 37717.8, 37718.4, 37717.7, 37718.1, 37718.8, 37718, 37719.5, 37718.4, 37719.2, 37719.5, 37718.9, 37719.9, 37718.2, 37717.5, 37718.4, 37718.1, 37718.5, 37718.1, 37718.7, 37718.6, 37719.6, 37718.8, 37719.7, 37717.7, 37718.5, 37717, 37718.2, 37718.4, 37717.4, 37718.4, 37717.6, 37717.9, 37718, 37718.1, 37718.8, 37717.8, 37718.4, 37719.2, 37718.9, 37717.7, 37719.4, 37718.1, 37719, 37718.6, 37716.9, 37717, 37719.7, 37717.9, 37717.7, 37717.8, 37718, 37719.2, 37717.5, 37718.3, 37718.9, 37718.2, 37718.9, 37717.9, 37718.4, 37719, 37717.9, 37717.7, 37717.8, 37719.3, 37718.8, 37716.7, 37719.6, 37717.9, 37718.1, 37719, 37719, 37717.8, 37718.5, 37718.9, 37718.7, 37718.6, 37719, 37719, 37718.6, 37718, 37718.2, 37719, 37718.9, 37719, 37719.5, 37719.8, 37718.2, 37717.9, 37717.7, 37717.1, 37717.8, 37718, 37717.8, 37718.4, 37718.7, 37718.6, 37719, 37719.2, 37719.1, 37718.2, 37718.9, 37719.8, 37717.6, 37717.8, 37719.4, 37717.5, 37717.6, 37719.7, 37718.6, 37717.9, 37718.3, 37717.7, 37719.4, 37719.8, 37718, 37718.7, 37719.5, 37719.2, 37718, 37718.6, 37717.9, 37718.9, 37718.7, 37719.3}};

    // Main tree for analysis -- one fill per interaction
    if ( !_tree ){
      _tree = new TTree("tree","");
      _tree->Branch("event_id",&_event_id,"event_id/I");
      _tree->Branch("subrun_id",&_subrun_id,"subrun_id/I");
      _tree->Branch("run_id",&_run_id,"run_id/I");
      _tree->Branch("event",&_event,"event/I");
      _tree->Branch("bkgd_id",&_bkgd_id,"bkgd_id/I");
      _tree->Branch("nu_mode",&_nu_mode,"nu_mode/I");
      _tree->Branch("nshrs",&_nshrs,"nshrs/I");
      // Vertex
      _tree->Branch("vtx_x",&_vtx_x,"vtx_x/F");
      _tree->Branch("vtx_y",&_vtx_y,"vtx_y/F");
      _tree->Branch("vtx_z",&_vtx_z,"vtx_z/F");
      _tree->Branch("mc_vtx_x",&_mc_vtx_x,"mc_vtx_x/F");
      _tree->Branch("mc_vtx_y",&_mc_vtx_y,"mc_vtx_y/F");
      _tree->Branch("mc_vtx_z",&_mc_vtx_z,"mc_vtx_z/F");
      _tree->Branch("mc_scecorr_vtx_x",&_mc_scecorr_vtx_x,"mc_scecorr_vtx_x/F");
      _tree->Branch("mc_scecorr_vtx_y",&_mc_scecorr_vtx_y,"mc_scecorr_vtx_y/F");
      _tree->Branch("mc_scecorr_vtx_z",&_mc_scecorr_vtx_z,"mc_scecorr_vtx_z/F");
      // Flashes
      _tree->Branch("flash_time",&_flash_time,"flash_time/F");
      _tree->Branch("flash_pe",&_flash_pe,"flash_pe/I");
      _tree->Branch("flash_y_center",&_flash_y_center,"flash_y_center/F");
      _tree->Branch("flash_z_center",&_flash_z_center,"flash_z_center/F");
      _tree->Branch("flash_y_width",&_flash_y_width,"flash_y_width/F");
      _tree->Branch("flash_z_width",&_flash_z_width,"flash_z_width/F");
      // Candidate Muon
      _tree->Branch("mu_true_angle",&_mu_true_angle,"mu_true_angle/F");
      _tree->Branch("mu_true_phi",&_mu_true_phi,"mu_true_phi/F");
      _tree->Branch("mu_true_mom",&_mu_true_mom,"mu_true_mom/F");
      _tree->Branch("mu_true_startx",&_mu_true_startx,"mu_true_startx/F");
      _tree->Branch("mu_true_starty",&_mu_true_starty,"mu_true_starty/F");
      _tree->Branch("mu_true_startz",&_mu_true_startz,"mu_true_startz/F");
      _tree->Branch("mu_true_endx",&_mu_true_endx,"mu_true_endx/F");
      _tree->Branch("mu_true_endy",&_mu_true_endy,"mu_true_endy/F");
      _tree->Branch("mu_true_endz",&_mu_true_endz,"mu_true_endz/F");
      _tree->Branch("mu_angle",&_mu_angle,"mu_angle/F");
      _tree->Branch("mu_len",&_mu_len,"mu_len/F");
      _tree->Branch("mu_startx",&_mu_startx,"mu_startx/F");
      _tree->Branch("mu_starty",&_mu_starty,"mu_starty/F");
      _tree->Branch("mu_startz",&_mu_startz,"mu_startz/F");
      _tree->Branch("mu_dirx",&_mu_dirx,"mu_dirx/F");
      _tree->Branch("mu_diry",&_mu_diry,"mu_diry/F");
      _tree->Branch("mu_dirz",&_mu_dirz,"mu_dirz/F");
      _tree->Branch("mu_endx",&_mu_endx,"mu_endx/F");
      _tree->Branch("mu_endy",&_mu_endy,"mu_endy/F");
      _tree->Branch("mu_endz",&_mu_endz,"mu_endz/F");
      _tree->Branch("mu_phi",&_mu_phi,"mu_phi/F");
      _tree->Branch("mult",&_mult,"mult/F");
      _tree->Branch("mu_purity",&_mu_purity,"mu_purity/F");
      _tree->Branch("mu_complete",&_mu_complete,"mu_complete/F");
      _tree->Branch("mu_cw_purity",&_mu_cw_purity,"mu_cw_purity/F");
      _tree->Branch("mu_cw_complete",&_mu_cw_complete,"mu_cw_complete/F");
      _tree->Branch("mu_origin",&_mu_origin,"mu_origin/F");
      _tree->Branch("mu_type",&_mu_type,"mu_type/F");
      _tree->Branch("mu_pdg",&_mu_pdg,"mu_pdg/I");
      _tree->Branch("mu_mother_pdg",&_mu_mother_pdg,"mu_mother_pdg/I");
      _tree->Branch("mu_deviation",&_mu_deviation,"mu_deviation/F");
      _tree->Branch("mu_trun_mean_dqdx",&_mu_trun_mean_dqdx,"mu_trun_mean_dqdx/F");
      _tree->Branch("mu_pdg",&_mu_pdg,"mu_pdg/I");

      // Showers
      _tree->Branch("n_mcs_at_vtx",&_n_mcs_at_vtx,"n_mcs_at_vtx/I");
      _tree->Branch("n_reco_at_vtx",&_n_reco_at_vtx,"n_reco_at_vtx/I");
      // Candidate pi0 showers -- only filled when _get_pi0_info is true
      _tree->Branch("pi0_mass",&_pi0_mass,"pi0_mass/F");
      _tree->Branch("pi0_oangle",&_pi0_oangle,"pi0_oangle/F");
      _tree->Branch("pi0_true_oangle",&_pi0_true_oangle,"pi0_true_oangle/F");
      _tree->Branch("pi0_IP",&_pi0_IP,"pi0_IP/F");
      _tree->Branch("pi0_mom",&_pi0_mom,"pi0_mom/F");
      //_tree->Branch("pi0_low_shrE",&_pi0_low_shrE,"pi0_low_shrE/F");
      _tree->Branch("pi0_low_radL",&_pi0_low_radL,"pi0_low_radL/F");
      _tree->Branch("pi0_low_IP_w_vtx",&_pi0_low_IP_w_vtx,"pi0_low_IP_w_vtx/F");
      _tree->Branch("pi0_low_purity",&_pi0_low_purity,"pi0_low_purity/F");
      _tree->Branch("pi0_low_complete",&_pi0_low_complete,"pi0_low_complete/F");
      _tree->Branch("pi0_low_cw_purity",&_pi0_low_cw_purity,"pi0_low_cw_purity/F");
      _tree->Branch("pi0_low_cw_complete",&_pi0_low_cw_complete,"pi0_low_cw_complete/F");
      _tree->Branch("pi0_low_true_gammaE",&_pi0_low_true_gammaE,"pi0_low_true_gammaE/F");
      _tree->Branch("pi0_low_true_detProf_gammaE",&_pi0_low_true_detProf_gammaE,"pi0_low_true_detProf_gammaE/F");
      _tree->Branch("pi0_low_perfect_clustering_E",&_pi0_low_perfect_clustering_E,"pi0_low_perfect_clustering_E/F");
      _tree->Branch("pi0_low_reco_gammaE",&_pi0_low_reco_gammaE,"pi0_low_reco_gammaE/F");
      _tree->Branch("pi0_low_origin",&_pi0_low_origin,"pi0_low_origin/F");
      _tree->Branch("pi0_low_type",&_pi0_low_type,"pi0_low_type/F");
      _tree->Branch("pi0_low_from_pi0",&_pi0_low_from_pi0,"pi0_low_from_pi0/B");
      _tree->Branch("pi0_low_st_x",&_pi0_low_st_x,"pi0_low_st_x/F");
      _tree->Branch("pi0_low_st_y",&_pi0_low_st_y,"pi0_low_st_y/F");
      _tree->Branch("pi0_low_st_z",&_pi0_low_st_z,"pi0_low_st_z/F");
      _tree->Branch("pi0_low_true_scecorr_st_x",&_pi0_low_true_scecorr_st_x,"pi0_low_true_scecorr_st_x/F");
      _tree->Branch("pi0_low_true_scecorr_st_y",&_pi0_low_true_scecorr_st_y,"pi0_low_true_scecorr_st_y/F");
      _tree->Branch("pi0_low_true_scecorr_st_z",&_pi0_low_true_scecorr_st_z,"pi0_low_true_scecorr_st_z/F");
      _tree->Branch("pi0_low_true_st_x",&_pi0_low_true_st_x,"pi0_low_true_st_x/F");
      _tree->Branch("pi0_low_true_st_y",&_pi0_low_true_st_y,"pi0_low_true_st_y/F");
      _tree->Branch("pi0_low_true_st_z",&_pi0_low_true_st_z,"pi0_low_true_st_z/F");
      _tree->Branch("pi0_low_true_detProf_st_x",&_pi0_low_true_detProf_st_x,"pi0_low_true_detProf_st_x/F");
      _tree->Branch("pi0_low_true_detProf_st_y",&_pi0_low_true_detProf_st_y,"pi0_low_true_detProf_st_y/F");
      _tree->Branch("pi0_low_true_detProf_st_z",&_pi0_low_true_detProf_st_z,"pi0_low_true_detProf_st_z/F");
      _tree->Branch("pi0_low_dist_to_nearest_trk",&_pi0_low_dist_to_nearest_trk,"pi0_low_dist_to_nearest_trk/F");
      _tree->Branch("pi0_low_mother_pdg",&_pi0_low_mother_pdg,"pi0_low_mother_pdg/I");
      _tree->Branch("pi0_low_pdg",&_pi0_low_pdg,"pi0_low_pdg/I");
      _tree->Branch("pi0_low_mom_x",&_pi0_low_mom_x,"pi0_low_mom_x/F");
      _tree->Branch("pi0_low_mom_y",&_pi0_low_mom_y,"pi0_low_mom_y/F");
      _tree->Branch("pi0_low_mom_z",&_pi0_low_mom_z,"pi0_low_mom_z/F");
      //_tree->Branch("pi0_high_shrE",&_pi0_high_shrE,"pi0_high_shrE/F");
      _tree->Branch("pi0_high_radL",&_pi0_high_radL,"pi0_high_radL/F");
      _tree->Branch("pi0_high_IP_w_vtx",&_pi0_high_IP_w_vtx,"pi0_high_IP_w_vtx/F");
      _tree->Branch("pi0_high_purity",&_pi0_high_purity,"pi0_high_purity/F");
      _tree->Branch("pi0_high_complete",&_pi0_high_complete,"pi0_high_complete/F");
      _tree->Branch("pi0_high_cw_purity",&_pi0_high_cw_purity,"pi0_high_cw_purity/F");
      _tree->Branch("pi0_high_cw_complete",&_pi0_high_cw_complete,"pi0_high_cw_complete/F");
      _tree->Branch("pi0_high_true_gammaE",&_pi0_high_true_gammaE,"pi0_high_true_gammaE/F");
      _tree->Branch("pi0_high_true_detProf_gammaE",&_pi0_high_true_detProf_gammaE,"pi0_high_true_detProf_gammaE/F");
      _tree->Branch("pi0_high_perfect_clustering_E",&_pi0_high_perfect_clustering_E,"pi0_high_perfect_clustering_E/F");
      _tree->Branch("pi0_high_reco_gammaE",&_pi0_high_reco_gammaE,"pi0_low_reco_gammaE/F");
      _tree->Branch("pi0_high_origin",&_pi0_high_origin,"pi0_high_origin/F");
      _tree->Branch("pi0_high_type",&_pi0_high_type,"pi0_high_type/F");
      _tree->Branch("pi0_high_from_pi0",&_pi0_high_from_pi0,"pi0_high_from_pi0/B");
      _tree->Branch("pi0_high_st_x",&_pi0_high_st_x,"pi0_high_st_x/F");
      _tree->Branch("pi0_high_st_y",&_pi0_high_st_y,"pi0_high_st_y/F");
      _tree->Branch("pi0_high_st_z",&_pi0_high_st_z,"pi0_high_st_z/F");
      _tree->Branch("pi0_high_true_scecorr_st_x",&_pi0_high_true_scecorr_st_x,"pi0_high_true_scecorr_st_x/F");
      _tree->Branch("pi0_high_true_scecorr_st_y",&_pi0_high_true_scecorr_st_y,"pi0_high_true_scecorr_st_y/F");
      _tree->Branch("pi0_high_true_scecorr_st_z",&_pi0_high_true_scecorr_st_z,"pi0_high_true_scecorr_st_z/F");
      _tree->Branch("pi0_high_true_st_x",&_pi0_high_true_st_x,"pi0_high_true_st_x/F");
      _tree->Branch("pi0_high_true_st_y",&_pi0_high_true_st_y,"pi0_high_true_st_y/F");
      _tree->Branch("pi0_high_true_st_z",&_pi0_high_true_st_z,"pi0_high_true_st_z/F");
      _tree->Branch("pi0_high_true_detProf_st_x",&_pi0_high_true_detProf_st_x,"pi0_high_true_detProf_st_x/F");
      _tree->Branch("pi0_high_true_detProf_st_y",&_pi0_high_true_detProf_st_y,"pi0_high_true_detProf_st_y/F");
      _tree->Branch("pi0_high_true_detProf_st_z",&_pi0_high_true_detProf_st_z,"pi0_high_true_detProf_st_z/F");
      _tree->Branch("pi0_high_dist_to_nearest_trk",&_pi0_high_dist_to_nearest_trk,"pi0_high_dist_to_nearest_trk/F");
      _tree->Branch("pi0_high_mother_pdg",&_pi0_high_mother_pdg,"pi0_high_mother_pdg/I");
      _tree->Branch("pi0_high_pdg",&_pi0_high_pdg,"pi0_high_pdg/I");
      _tree->Branch("pi0_high_mom_x",&_pi0_high_mom_x,"pi0_high_mom_x/F");
      _tree->Branch("pi0_high_mom_y",&_pi0_high_mom_y,"pi0_high_mom_y/F");
      _tree->Branch("pi0_high_mom_z",&_pi0_high_mom_z,"pi0_high_mom_z/F");
      // Candidate single shower samples -- only filled when _get_single_shower_info is true
      _tree->Branch("gamma_E",&_gamma_E,"gamma_E/F");
      _tree->Branch("gamma_RL",&_gamma_RL,"gamma_RL/F");
      _tree->Branch("gamma_IP_w_vtx",&_gamma_IP_w_vtx,"gamma_IP_w_vtx/F");
      _tree->Branch("gamma_startx",&_gamma_startx,"gamma_startx/F");
      _tree->Branch("gamma_starty",&_gamma_starty,"gamma_starty/F");
      _tree->Branch("gamma_startz",&_gamma_startz,"gamma_startz/F");
      _tree->Branch("gamma_true_startx",&_gamma_true_startx,"gamma_true_startx/F");
      _tree->Branch("gamma_true_starty",&_gamma_true_starty,"gamma_true_starty/F");
      _tree->Branch("gamma_true_startz",&_gamma_true_startz,"gamma_true_startz/F");
      _tree->Branch("gamma_true_detProf_startx",&_gamma_true_detProf_startx,"gamma_true_detProf_startx/F");
      _tree->Branch("gamma_true_detProf_starty",&_gamma_true_detProf_starty,"gamma_true_detProf_starty/F");
      _tree->Branch("gamma_true_detProf_startz",&_gamma_true_detProf_startz,"gamma_true_detProf_startz/F");
      _tree->Branch("gamma_purity",&_gamma_purity,"gamma_purity/F");
      _tree->Branch("gamma_complete",&_gamma_complete,"gamma_complete/F");
      _tree->Branch("gamma_cw_purity",&_gamma_cw_purity,"gamma_cw_purity/F");
      _tree->Branch("gamma_cw_complete",&_gamma_cw_complete,"gamma_cw_complete/F");
      _tree->Branch("gamma_trueE",&_gamma_trueE,"gamma_trueE/F");
      _tree->Branch("gamma_trueE_detProf",&_gamma_trueE_detProf,"gamma_trueE_detProf/F");
      _tree->Branch("gamma_perfect_clustering_E",&_gamma_perfect_clustering_E,"gamma_perfect_clustering_E/F");
      _tree->Branch("gamma_origin",&_gamma_origin,"gamma_origin/F");
      _tree->Branch("gamma_type",&_gamma_type,"gamma_type/F");
      _tree->Branch("gamma_from_pi0",&_gamma_from_pi0,"gamma_from_pi0/B");
      _tree->Branch("gamma_pdg",&_gamma_pdg,"gamma_pdg/I");
      _tree->Branch("gamma_mother_pdg",&_gamma_mother_pdg,"gamma_mother_pdg/I");
      // post technote version v0.9
      _tree->Branch("n_track_hits_0",&_n_track_hits_0,"n_track_hits_0/I");
      _tree->Branch("n_track_hits_1",&_n_track_hits_1,"n_track_hits_1/I");
      _tree->Branch("n_track_hits_2",&_n_track_hits_2,"n_track_hits_2/I");
      _tree->Branch("n_shower_hits_0",&_n_shower_hits_0,"n_shower_hits_0/I");
      _tree->Branch("n_shower_hits_1",&_n_shower_hits_1,"n_shower_hits_1/I");
      _tree->Branch("n_shower_hits_2",&_n_shower_hits_2,"n_shower_hits_2/I");
      _tree->Branch("n_shr_pi0",&_n_shr_pi0,"n_shr_pi0/I");
      _tree->Branch("n_shr_nushr",&_n_shr_nushr,"n_shr_nushr/I");
      _tree->Branch("n_shr_nutrk",&_n_shr_nutrk,"n_shr_nutrk/I");
      _tree->Branch("n_shr_cosmic",&_n_shr_cosmic,"n_shr_cosmic/I");
      _tree->Branch("n_shr_noise",&_n_shr_noise,"n_shr_noise/I");
      _tree->Branch("sel_evts_m1","std::vector<float>",&_sel_evts_m1);
      _tree->Branch("sel_evts_p1","std::vector<float>",&_sel_evts_p1);
      _tree->Branch("sig_evts_m1","std::vector<float>",&_sig_evts_m1);
      _tree->Branch("sig_evts_p1","std::vector<float>",&_sig_evts_p1);
      _tree->Branch("bkgd_evts_m1","std::vector<float>",&_bkgd_evts_m1);
      _tree->Branch("bkgd_evts_p1","std::vector<float>",&_bkgd_evts_p1);
      _tree->Branch("signal",&_signal,"signal/B");
      _tree->Branch("genie_weight_up",&_genie_weight_up,"genie_weight_up/F");
      _tree->Branch("genie_weight_dn",&_genie_weight_dn,"genie_weight_dn/F");
      _tree->Branch("flux_weight_up",&_flux_weight_up,"flux_weight_up/F");
      _tree->Branch("flux_weight_dn",&_flux_weight_dn,"flux_weight_dn/F");
      _tree->Branch("flux_weights","std::vector<float>",&_flux_weights);
   }

    // Filled per reconstructed shower
    if(!_shower_tree){
      _shower_tree = new TTree("shower_tree","");
      _shower_tree->Branch("event",&_event,"event/I");
      _shower_tree->Branch("bkgd_id",&_bkgd_id,"bkgd_id/I");
      _shower_tree->Branch("shr_startx",&_shr_startx,"shr_startx/F");
      _shower_tree->Branch("shr_starty",&_shr_starty,"shr_starty/F");
      _shower_tree->Branch("shr_startz",&_shr_startz,"shr_startz/F");
      _shower_tree->Branch("shr_startw",&_shr_startw,"shr_startw/F");
      _shower_tree->Branch("shr_startt",&_shr_startt,"shr_startt/F");
      _shower_tree->Branch("shr_dirx",&_shr_dirx,"shr_dirx/F");
      _shower_tree->Branch("shr_diry",&_shr_diry,"shr_diry/F");
      _shower_tree->Branch("shr_dirz",&_shr_dirz,"shr_dirz/F");
      _shower_tree->Branch("shr_energy",&_shr_energy,"shr_energy/F");
      _shower_tree->Branch("shr_true_startx",&_shr_true_startx,"shr_true_startx/F");
      _shower_tree->Branch("shr_true_starty",&_shr_true_starty,"shr_true_starty/F");
      _shower_tree->Branch("shr_true_startz",&_shr_true_startz,"shr_true_startz/F");
      _shower_tree->Branch("shr_true_detProf_dirx",&_shr_true_detProf_dirx,"shr_true_detProf_dirx/F");
      _shower_tree->Branch("shr_true_detProf_diry",&_shr_true_detProf_diry,"shr_true_detProf_diry/F");
      _shower_tree->Branch("shr_true_detProf_dirz",&_shr_true_detProf_dirz,"shr_true_detProf_dirz/F");
      _shower_tree->Branch("shr_dir_res",&_shr_dir_res,"shr_dir_res/F");
      _shower_tree->Branch("shr_true_detProf_startx",&_shr_true_detProf_startx,"shr_true_detProf_startx/F");
      _shower_tree->Branch("shr_true_detProf_starty",&_shr_true_detProf_starty,"shr_true_detProf_starty/F");
      _shower_tree->Branch("shr_true_detProf_startz",&_shr_true_detProf_startz,"shr_true_detProf_startz/F");
      _shower_tree->Branch("shr_start_res",&_shr_start_res,"shr_start_res/F");
      _shower_tree->Branch("shr_trueE",&_shr_trueE,"shr_trueE/F");
      _shower_tree->Branch("shr_trueE_detProf",&_shr_trueE_detProf,"shr_trueE_detProf/F");
      _shower_tree->Branch("shr_perfect_clustering_E",&_shr_perfect_clustering_E,"shr_perfect_clustering_E/F");
      _shower_tree->Branch("shr_oangle",&_shr_oangle,"shr_oangle/F");
      _shower_tree->Branch("shr_dedx",&_shr_dedx,"shr_dedx/F");
      _shower_tree->Branch("shr_vtx_dist",&_shr_vtx_dist,"shr_vtx_dist/F");
      _shower_tree->Branch("shr_trk_delta_theta",&_shr_trk_delta_theta,"shr_trk_delta_theta/F");
      _shower_tree->Branch("shr_trk_delta_phi",&_shr_trk_delta_phi,"shr_trk_delta_phi/F");
      // post technote version v0.9
      _shower_tree->Branch("shr_ip",&_shr_ip,"shr_ip/F");
      _shower_tree->Branch("shr_rl",&_shr_rl,"shr_rl/F");
      _shower_tree->Branch("shr_purity",&_shr_purity,"shr_purity/F");
      _shower_tree->Branch("shr_complete",&_shr_complete,"shr_complete/F");
      _shower_tree->Branch("shr_origin",&_shr_origin,"shr_origin/F");
      _shower_tree->Branch("shr_type",&_shr_type,"shr_type/F");
      _shower_tree->Branch("shr_from_pi0",&_shr_from_pi0,"shr_from_pi0/B");
      _shower_tree->Branch("shr_pdg",&_shr_pdg,"shr_pdg/I");
      _shower_tree->Branch("shr_mother_pdg",&_shr_mother_pdg,"shr_mother_pdg/I");
      _shower_tree->Branch("shr_n_true",&_shr_n_true,"shr_n_true/I");
      _shower_tree->Branch("shr_n_reco",&_shr_n_reco,"shr_n_reco/I");
      /////// Adding some stuff
      _shower_tree->Branch("flash_pe",&_flash_pe,"flash_pe/I");
      _shower_tree->Branch("flash_y_center",&_flash_y_center,"flash_y_center/F");
      _shower_tree->Branch("flash_z_center",&_flash_z_center,"flash_z_center/F");
      _shower_tree->Branch("flash_y_width",&_flash_y_width,"flash_y_width/F");
      _shower_tree->Branch("flash_z_width",&_flash_z_width,"flash_z_width/F");
      _shower_tree->Branch("mu_true_angle",&_mu_true_angle,"mu_true_angle/F");
      _shower_tree->Branch("mu_true_phi",&_mu_true_phi,"mu_true_phi/F");
      _shower_tree->Branch("mu_true_mom",&_mu_true_mom,"mu_true_mom/F");
      _shower_tree->Branch("mu_angle",&_mu_angle,"mu_angle/F");
      _shower_tree->Branch("mu_len",&_mu_len,"mu_len/F");
      _shower_tree->Branch("mu_startx",&_mu_startx,"mu_startx/F");
      _shower_tree->Branch("mu_starty",&_mu_starty,"mu_starty/F");
      _shower_tree->Branch("mu_startz",&_mu_startz,"mu_startz/F");
      _shower_tree->Branch("mu_dirx",&_mu_dirx,"mu_dirx/F");
      _shower_tree->Branch("mu_diry",&_mu_diry,"mu_diry/F");
      _shower_tree->Branch("mu_dirz",&_mu_dirz,"mu_dirz/F");
      _shower_tree->Branch("mu_endx",&_mu_endx,"mu_endx/F");
      _shower_tree->Branch("mu_endy",&_mu_endy,"mu_endy/F");
      _shower_tree->Branch("mu_endz",&_mu_endz,"mu_endz/F");
      _shower_tree->Branch("mu_phi",&_mu_phi,"mu_phi/F");
      _shower_tree->Branch("mult",&_mult,"mult/F");
      _shower_tree->Branch("mu_deviation",&_mu_deviation,"mu_deviation/F");
      _shower_tree->Branch("mu_trun_mean_dqdx",&_mu_trun_mean_dqdx,"mu_trun_mean_dqdx/F");
      _shower_tree->Branch("mu_pdg",&_mu_pdg,"mu_pdg/I");
      _shower_tree->Branch("n_track_hits_0",&_n_track_hits_0,"n_track_hits_0/I");
      _shower_tree->Branch("n_track_hits_1",&_n_track_hits_1,"n_track_hits_1/I");
      _shower_tree->Branch("n_track_hits_2",&_n_track_hits_2,"n_track_hits_2/I");
      _shower_tree->Branch("n_shower_hits_0",&_n_shower_hits_0,"n_shower_hits_0/I");
      _shower_tree->Branch("n_shower_hits_1",&_n_shower_hits_1,"n_shower_hits_1/I");
      _shower_tree->Branch("n_shower_hits_2",&_n_shower_hits_2,"n_shower_hits_2/I");


    }   

    // For analysis of GENIE and flux xsec uncertainties -- filled once in finalize() function
    if( !_univ) {
       _univ = new TTree("univ","");
       _univ->Branch("sig_v","std::vector<std::vector<float>>",&_sig_v); 
       _univ->Branch("bkgd_v","std::vector<std::vector<float>>",&_b_weights_by_universe); 
       _univ->Branch("tot_v","std::vector<std::vector<float>>",&_tot_v); 
       _univ->Branch("eff_v","std::vector<std::vector<float>>",&_eff_v); 
       _univ->Branch("xsec_v","std::vector<std::vector<float>>",&_xsec_v); 
       _univ->Branch("perc_v","std::vector<std::vector<float>>",&_perc_v); 
     }

    return true;
  }

  void BackgroundTruthMatchBT::clear(){

    _event_id = -1;
    _subrun_id = -1;
    _run_id = -1;
     
    _bkgd_id = -1 ;
    _nu_mode = -1 ;
    _nshrs = -1 ;
    _mult    = 0;
    
    _vtx_x   = -999;
    _vtx_y   = -999;
    _vtx_z   = -999;
    _mc_vtx_x   = -999;
    _mc_vtx_y   = -999;
    _mc_vtx_z   = -999;
    _mc_scecorr_vtx_x   = -999;
    _mc_scecorr_vtx_y   = -999;
    _mc_scecorr_vtx_z   = -999;

    _flash_time = -999;
    _flash_pe = -1 ;
    _flash_y_center = -999;
    _flash_z_center = -999;
    _flash_y_width = -999;
    _flash_z_width = -999;

    _mu_true_angle = -999;
    _mu_true_phi  = -999;
    _mu_true_mom  = -999;
    _mu_true_startx = -999;
    _mu_true_starty = -999;
    _mu_true_startz = -999;
    _mu_true_endx = -999;
    _mu_true_endy = -999;
    _mu_true_endz = -999;

    _mu_angle = -999;
    _mu_len   = -999;
    _mu_startx = -999;
    _mu_starty = -999;
    _mu_startz = -999;
    _mu_dirx = -999;
    _mu_diry = -999;
    _mu_dirz = -999;
    _mu_endx = -999;
    _mu_endy = -999;
    _mu_endz = -999;
    _mu_phi  = -999;
    _mu_complete  = 0.;
    _mu_purity  = 0.;
    _mu_cw_complete  = 0.;
    _mu_cw_purity  = 0.;
    _mu_origin = -1;  // 1 is nu, 2 cosmic, -1 is noise
    _mu_type   = -1 ; // 0 is track
    _mu_pdg = -1;  
    _mu_mother_pdg = -1;  

    _n_mcs_at_vtx = 0;
    _n_reco_at_vtx = 0;

    _pi0_mass = -999;
    _pi0_oangle = -999;
    _pi0_true_oangle = -999;
    _pi0_IP = -999;
    _pi0_mom = -999;
    //_pi0_low_shrE = -999;
    _pi0_low_radL = -999;
    _pi0_low_IP_w_vtx = -999;
    _pi0_low_purity = 0.;
    _pi0_low_complete = 0.;
    _pi0_low_cw_purity = 0.;
    _pi0_low_cw_complete = 0.;
    _pi0_low_true_gammaE = -999;
    _pi0_low_true_detProf_gammaE = -999;
    _pi0_low_perfect_clustering_E = -999;
    _pi0_low_reco_gammaE= -999;
    _pi0_low_origin = -1;
    _pi0_low_type = -1 ; // 1 is shower, 0 is track
    _pi0_low_from_pi0= false ; 
    _pi0_low_st_x  = -999;
    _pi0_low_st_y  = -999;
    _pi0_low_st_z  = -999;
    _pi0_low_true_scecorr_st_x = -999;
    _pi0_low_true_scecorr_st_y = -999;
    _pi0_low_true_scecorr_st_z = -999;
    _pi0_low_true_st_x = -999;
    _pi0_low_true_st_y = -999;
    _pi0_low_true_st_z = -999;
    _pi0_low_true_detProf_st_x = -999;
    _pi0_low_true_detProf_st_y = -999;
    _pi0_low_true_detProf_st_z = -999;
    _pi0_low_dist_to_nearest_trk = -999 ;
    _pi0_low_mother_pdg = -1;
    _pi0_low_pdg = -1;
    _pi0_low_mom_x = -999;
    _pi0_low_mom_y = -999;
    _pi0_low_mom_z = -999;

    //_pi0_high_shrE = -999;
    _pi0_high_radL = -999;
    _pi0_high_IP_w_vtx = -999;
    _pi0_high_purity = 0.;
    _pi0_high_complete = 0.;
    _pi0_high_cw_purity = 0.;
    _pi0_high_cw_complete = 0.;
    _pi0_high_true_gammaE = -999;
    _pi0_high_true_detProf_gammaE = -999;
    _pi0_high_perfect_clustering_E = -999;
    _pi0_high_reco_gammaE= -999;
    _pi0_high_origin = -1 ;
    _pi0_high_type = -1  ; // true is shower
    _pi0_high_from_pi0 = false ; 
    _pi0_high_st_x = -999 ;
    _pi0_high_st_y = -999 ;
    _pi0_high_st_z = -999 ;
    _pi0_high_true_scecorr_st_x= -999 ;
    _pi0_high_true_scecorr_st_y= -999 ;
    _pi0_high_true_scecorr_st_z= -999 ;
    _pi0_high_true_st_x= -999 ;
    _pi0_high_true_st_y= -999 ;
    _pi0_high_true_st_z= -999 ;
    _pi0_high_true_detProf_st_x= -999 ;
    _pi0_high_true_detProf_st_y= -999 ;
    _pi0_high_true_detProf_st_z= -999 ;
    _pi0_high_dist_to_nearest_trk = -999 ;
    _pi0_high_mother_pdg = -1;
    _pi0_high_pdg = -1;
    _pi0_high_mom_x = -999;
    _pi0_high_mom_y = -999;
    _pi0_high_mom_z = -999;

    _gamma_startx = -999 ;
    _gamma_starty = -999 ;
    _gamma_startz = -999 ;
    _gamma_true_startx = -999 ;
    _gamma_true_starty = -999 ;
    _gamma_true_startz = -999 ;
    _gamma_true_detProf_startx = -999 ;
    _gamma_true_detProf_starty = -999 ;
    _gamma_true_detProf_startz = -999 ;
    _gamma_E = -999;
    _gamma_RL = -999;
    _gamma_IP_w_vtx = -999;
    _gamma_purity = 0.;
    _gamma_complete = 0.;
    _gamma_cw_purity = 0.;
    _gamma_cw_complete = 0.;
    _gamma_trueE = -999;
    _gamma_trueE_detProf = -999;
    _gamma_perfect_clustering_E = -999;
    _gamma_origin = -1;
    _gamma_type = -1 ;
    _gamma_from_pi0 = false;
    _gamma_pdg = -1;
    _gamma_mother_pdg = -1;


    // additions post technote version v0.9
    _n_track_hits_0 = 0;
    _n_track_hits_1 = 0;
    _n_track_hits_2 = 0;
    _n_shower_hits_0 = 0;
    _n_shower_hits_1 = 0;
    _n_shower_hits_2 = 0;

    _shr_ip = -999;
    _shr_rl = -999;
    _shr_complete = -999;
    _shr_purity = -999;
    _shr_origin = -999;
    _shr_type = -999;
    _shr_from_pi0 = false;

    _n_shr_pi0 = 0;   
    _n_shr_nutrk = 0;   
    _n_shr_nushr = 0;   
    _n_shr_cosmic = 0;   
    _n_shr_noise = 0;   

    _signal = false;

    // Adding GENIE + Flux weights 
    _genie_weight_up = 1;
    _genie_weight_dn = 1;
    _flux_weight_up = 1;
    _flux_weight_dn = 1;
    _total_weight_up = 1;
    _total_weight_dn = 1;

    if ( _get_genie_info ){ //_get_single_shower_info || _get_pi0_info || _get_preselection_flux_info ){ 
      _flux_weights.clear(); 
      _flux_weights.resize(1000,1);
    }

   }

  void BackgroundTruthMatchBT::shower_clear(){
  
    _shr_true_startx = -999;
    _shr_true_starty = -999;
    _shr_true_startz = -999;
    _shr_true_detProf_dirx = -999;
    _shr_true_detProf_diry = -999;
    _shr_true_detProf_dirz = -999;
    _shr_dir_res = -999;
    _shr_true_detProf_startx = -999;
    _shr_true_detProf_starty = -999;
    _shr_true_detProf_startz = -999;
    _shr_start_res = -999;
    _shr_startx = -999;
    _shr_starty = -999;
    _shr_startz = -999;
    _shr_startw = -999;
    _shr_startt = -999;
    _shr_dirx = -999;
    _shr_diry = -999;
    _shr_dirz = -999;
    _shr_energy = -999;
    _shr_trueE= -999;
    _shr_trueE_detProf= -999;
    _shr_perfect_clustering_E = -999;
    _shr_oangle = -999;
    _shr_dedx = -999;
    _shr_vtx_dist = -999;
    _shr_trk_delta_theta = -999;
    _shr_trk_delta_phi = -999;
    _shr_pdg = -1;
    _shr_mother_pdg = -1;
    _shr_n_true = -1;
    _shr_n_reco = -1;
  
  }

  double BackgroundTruthMatchBT::MaxDeflection(::larlite::track trk){

     double max = 0;
     std::vector<TVector3> mom;

     for(int i = 0; i < trk.NumberTrajectoryPoints(); i++){

         TVector3 nextpos;
         TVector3 nextmom;
         trk.TrajectoryAtPoint(i,nextpos,nextmom);
         mom.push_back(nextmom);

     }

     for(int i = 0; i < int(mom.size())-1; i++){
       if(max < mom.at(i).Angle(mom.at(i+1))) max = mom.at(i).Angle(mom.at(i+1));
     }

     return max*(180./3.14159265);

  }

  double BackgroundTruthMatchBT::Median(std::vector<double> input){

     int N = input.size();

     double median;

     std::sort(input.begin(), input.end());
     if (N % 2 == 0){ median = (input[((N/2) - 1)] + input[N/2]) / 2;}
     else if( N == 1){median = input[N];}
     else{            median = input[N/2];}
     return median;
  }

   double BackgroundTruthMatchBT::TrunMean(std::vector <double> poop){

     double RMS = TMath::RMS(poop.begin(),poop.end());
     double median = Median(poop);

     std::vector<double> TLMean;

     for(int i = 0; i < int(poop.size()); i++){
       if(poop[i] < median+RMS && poop[i] > median-RMS){TLMean.push_back(poop[i]);}
     }

     return TMath::Mean(TLMean.begin(), TLMean.end());
  }


  bool BackgroundTruthMatchBT::analyze(storage_manager* storage) {

    _event++ ;
    //std::cout<<"\n\nEVENT IS: "<<_event<<std::endl;
    clear();

    if ( _remove_duplicates ){

      auto r = storage->run_id() ;
      auto it = _map_v.at(r).find(storage->subrun_id());
      bool foundit = false;

      if( it != _map_v.at(r).end() ){
       while ( it->first == storage->subrun_id() ){  
         auto temp_event = it->second ; 
         if( temp_event == storage->event_id() )
           foundit = true;

         it++; 
         }   
        if ( !foundit)
         _map_v.at(r).emplace(storage->subrun_id(), storage->event_id() );
      
        else{
          std::cout<<"Event: "<<_event<<std::endl;
          std::cout<<"Duplicates "<<storage->run_id()<<", "<<storage->subrun_id()<<", "<<storage->event_id()<<std::endl;
          return false ;
        }   
      }   
      else 
        _map_v.at(r).emplace(storage->subrun_id(), storage->event_id() );

      _event_no_dup++ ;
    }


    auto ev_shr = storage->get_data<event_shower>("showerreco");
    //if ( ev_shr->size() == 0 ) return false ;

    auto ev_vtx= storage->get_data<event_vertex>("numuCC_vertex"); 
    if(!ev_vtx || !ev_vtx->size() ) {
      std::cout<<"Event has no recovertex info "<<std::endl;
      return false;
    }

    _event_id = storage->event_id() ;
    _subrun_id = storage->subrun_id() ;
    _run_id = storage->run_id() ;

    auto vtx = ev_vtx->at(0); 
    _vtx_x = vtx.X();
    _vtx_y = vtx.Y();
    _vtx_z = vtx.Z();

    auto ev_tagged_trk = storage->get_data<event_track>("numuCC_track");
    if ( !ev_tagged_trk || !ev_tagged_trk->size() ){ std::cout<<"No Tagged Track!" <<std::endl ; return false; }

    auto tagged_trk = ev_tagged_trk->at(0) ;

    // Fill track information
    _mu_phi = tagged_trk.VertexDirection().Phi();
    _mu_angle = cos(tagged_trk.VertexDirection().Theta());
    _mu_len =   tagged_trk.Length(0); // Calculates the length from point 0 to end
    _mu_startx = tagged_trk.Vertex().X(); 
    _mu_starty = tagged_trk.Vertex().Y(); 
    _mu_startz = tagged_trk.Vertex().Z(); 
    _mu_dirx = tagged_trk.Vertex().Px(); 
    _mu_diry = tagged_trk.Vertex().Py(); 
    _mu_dirz = tagged_trk.Vertex().Pz(); 
    _mu_endx = tagged_trk.End().X(); 
    _mu_endy = tagged_trk.End().Y(); 
    _mu_endz = tagged_trk.End().Z(); 

    // Also identify mip parameters
    if ( _get_calo_info ){

      auto ev_t_p = storage->get_data<event_track>("pandoraNu");
      auto ev_calo= storage->get_data<event_calorimetry>("pandoraNucalo");

      if ( !ev_calo || ev_calo->size() == 0 ) {
        std::cout << "No such calo associated to track! " << std::endl;
        return false;
      }

      auto ev_ass = storage->get_data<larlite::event_ass>("pandoraNucalo");

      if ( !ev_ass || ev_ass->size() == 0 ) {
        std::cout << "No such association! " << std::endl;
        return false;
      }

      auto const& ass_calo_v = ev_ass->association(ev_t_p->id(), ev_calo->id());
      if ( ass_calo_v.size() == 0) {
        std::cout << "No ass from track => hit! " << std::endl;
        return false;
      }

      float min_dist = 1e9;
      int min_it = -1; 
      auto tag_st = tagged_trk.End() ;

      for ( int i = 0; i < ev_t_p->size(); i++){

        auto t = ev_t_p->at(i);
        auto st = t.End() ;
        auto dist = sqrt( pow(st.X() - tag_st.X(),2) + pow(st.Y() - tag_st.Y(),2) + pow(st.Z() - tag_st.Z(),2) );
        if ( dist < min_dist ){
          min_dist = dist;
          min_it = i;
        }
      }

      int N = 0;
      std::vector<double> dqdx; 

      // Get calo ID for plane 2 at the tagged track.
      auto calo_it = ass_calo_v.at(min_it).at(2) ;
      auto calo_i = ev_calo->at(calo_it); 

      for(int i = 0; i < calo_i.dQdx().size(); i++){

        if ( calo_i.dQdx().at(i) <= 0 ) continue;
        N++;

        if ( _mc_sample)
          dqdx.push_back(calo_i.dQdx().at(i) * 198.);
        else 
          dqdx.push_back(calo_i.dQdx().at(i) * 243.);
      }   

      if(N == 0)
        dqdx.clear(); 
      else{

        std::sort(dqdx.begin(),dqdx.end());
        auto TrackTLMeandQdx = TrunMean(dqdx);
        _mu_trun_mean_dqdx = TrackTLMeandQdx ;

        dqdx.clear();
      }
    }

    auto TrackMaxDeflection = MaxDeflection(tagged_trk);
    _mu_deviation = TrackMaxDeflection ;


    // Fill observed vertex multiplicity info + find ID of pandora track that is numuCC_track
    auto ev_trk = storage->get_data<event_track>("pandoraNu");
    int min_trk_dist = 1e9;
    int min_trk_dist_it = -1;

    for ( int ii = 0; ii < ev_trk->size(); ii++){

        auto t = ev_trk->at(ii);
        auto st = t.Vertex() ;
        auto end = t.End() ;

        auto dist_st = sqrt( pow(st.X() - vtx.X(),2) + pow(st.Y() - vtx.Y(),2) + pow(st.Z() - vtx.Z(),2) );
        auto dist_end = sqrt( pow(end.X() - vtx.X(),2) + pow(end.Y() - vtx.Y(),2) + pow(end.Z() - vtx.Z(),2) );

        if (dist_st < 3 || dist_end < 3)
          _mult ++ ;

        auto tag_end = tagged_trk.End() ;
        auto dist = sqrt( pow(tag_end.X() - end.X(),2) + pow(tag_end.Y() - end.Y(),2) + pow(tag_end.Z() - end.Z(),2) );
        if ( dist < min_trk_dist ){
	  min_trk_dist = dist ;
	  min_trk_dist_it = ii ;
	}
    }
    auto ev_flash = storage->get_data<larlite::event_opflash>("simpleFlashBeam");
    if ( ev_flash && ev_flash->size() ){
      
      int max_it = -1;
      int max_pe = -1;

      //std::cout<<"Flash size: "<<ev_flash->size()<<std::endl ;
      for( int ff = 0; ff < ev_flash->size(); ff++){
        auto f = ev_flash->at(ff);
        if ( f.TotalPE() > max_pe && f.Time() > _beam_min && f.Time() < _beam_max ) {
	  max_pe = f.TotalPE();
	  max_it = ff;
	}
      }

     // The Selection II algorithm chooses the maximum PE flash in the beam window 
     if ( max_it != -1 ){
      auto f = ev_flash->at(max_it);
      _flash_pe = f.TotalPE();
      _flash_time = f.Time();
      _flash_y_center = f.YCenter();
      _flash_z_center = f.ZCenter();
      _flash_y_width = f.YWidth();
      _flash_z_width = f.ZWidth();
     }
    }

    // Calculate information about track and shower like hits per plane
    auto ev_hit = storage->get_data<larlite::event_hit>("gaushit");

    if (!ev_hit || ev_hit->size() == 0){
      std::cout << "No hits! exit" << std::endl;
      return false;
    }   

    for ( auto const & h : *ev_hit ){

      if ( h.WireID().Plane == 0 ){
        if ( h.GoodnessOfFit() >= 0 )
	  _n_shower_hits_0++;
	else 
	  _n_track_hits_0++;
      }

      if ( h.WireID().Plane == 1 ){
        if ( h.GoodnessOfFit() >= 0 )
	  _n_shower_hits_1++;
	else 
	  _n_track_hits_1++;
      }

      if ( h.WireID().Plane == 2 ){
        if ( h.GoodnessOfFit() >= 0 )
	  _n_shower_hits_2++;
	else 
	  _n_track_hits_2++;
      }
    }

    std::vector<int> pur_ctr_v ;
    std::vector<float> cw_pur_ctr_v ;
    std::vector<int> all_mcs_v ; // For shower reco eff later in shower_tree

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Need to access the origin of the tagged muon. Thus, need to find the MCTrack truth match to
    // the tagged track and ask for its origin. 
    ///////////////////////////////////////////////////////////////////////////////////////////////
    if ( _mc_sample ){

      auto ev_mct = storage->get_data<event_mctrack>("mcreco");
      if ( !ev_mct || !ev_mct->size() ) {std::cout<<"No MCTrack!" <<std::endl ; return false; }

      auto ev_mcs = storage->get_data<event_mcshower>("mcreco") ;
      if ( !ev_mcs || !ev_mcs->size() ) {std::cout<<"No MCShower!" <<std::endl ; return false; }

      auto ev_mctruth= storage->get_data<event_mctruth>("generator"); 
      if(!ev_mctruth || !ev_mctruth->size() ) {
        std::cout<<"Event has no mctruth info "<<std::endl;
        return false;
      }

      auto ev_mcc = storage->get_data<event_cluster>("mccluster");

      auto & truth = ev_mctruth->at(0);
      auto & nu  = truth.GetNeutrino();

      _nu_mode = nu.Mode();
      // This makes plotting event type by neutrino interaction mode easier later, but has no other significance
      if (_nu_mode == 10) _nu_mode = 4;
      // Note mode = 10 is an MEC event

      auto traj = nu.Nu().Trajectory();
      auto mc_vtx_x = traj.at(traj.size() - 1).X();
      auto mc_vtx_y = traj.at(traj.size() - 1).Y();
      auto mc_vtx_z = traj.at(traj.size() - 1).Z();
      auto tvtx = traj.at(traj.size() - 1).T();

      auto vtxtick = (tvtx / 1000.) * 2.;
      auto vtxtimecm = vtxtick * _time2cm; 
      _vtxtimecm = vtxtick * _time2cm; 
      auto sce_corr = _SCE->GetPosOffsets(mc_vtx_x,mc_vtx_y,mc_vtx_z);

      _mc_vtx_x = mc_vtx_x;
      _mc_vtx_y = mc_vtx_y;
      _mc_vtx_z = mc_vtx_z;
      
      _mc_scecorr_vtx_x = mc_vtx_x + vtxtimecm + 0.7 - sce_corr.at(0);
      _mc_scecorr_vtx_y = mc_vtx_y + sce_corr.at(1);
      _mc_scecorr_vtx_z = mc_vtx_z + sce_corr.at(2);

      // Now get Mccluster info
      auto ev_ass = storage->get_data<larlite::event_ass>("mccluster");
      auto const& ass_keys = ev_ass->association_keys();

      if ( ass_keys.size() == 0 ) return false; 

      larlite::event_cluster *ev_mcclus = nullptr;
      auto ass_hit_clus_v = storage->find_one_ass( ass_keys[0].first, ev_mcclus, ev_ass->name() );

      larlite::event_hit *ev_mchit = nullptr;
      auto ass_mcclus_v = storage->find_one_ass( ass_keys[0].second, ev_mchit, ev_ass->name() );

      if (ass_hit_clus_v.size() == 0){
        std::cout << "No hit ass! exit" << std::endl;
        return false;
      }   
      if (ass_mcclus_v.size() == 0){
        std::cout << "No mcclus ass! exit" << std::endl;
        return false;
      }   

      auto ev_hit_cosRem = storage->get_data<event_hit>("pandoraCosmicHitRemoval"); 

      if ( !ev_hit_cosRem || ev_hit_cosRem->size() == 0 ) {
        std::cout << "No such hits associated to track! " << std::endl;
        return false;
      }

      auto ev_hr_ass = storage->get_data<larlite::event_ass>("pandoraNu"); 

      if ( !ev_hr_ass || ev_hr_ass->size() == 0 ) {
        std::cout << "No such association! " << std::endl;
        return false;
      }

      // Get association to trk => hit and hit => trk
      auto const& ass_hit_v = ev_hr_ass->association(ev_trk->id(), ev_hit_cosRem->id());

      if ( ass_hit_v.size() == 0) {
        std::cout << "No ass from track => hit! " << std::endl;
        return false;
      }

      // Keep track of the charge-weighted hit count
      std::map<int,float> tot_mc_cw_hits_v ; 

      _mc_hit_map.clear();

      // Fill map with hits from mccluster : clusterID
      for( int i = 0; i < ass_mcclus_v.size(); i ++ ){

        auto cid = ev_mcc->at(i) ;
        if ( cid.View() != 2 ) continue;

        for ( int j = 0; j < ass_mcclus_v[i].size(); j++ ){

          auto hid = ass_mcclus_v[i][j];
          _mc_hit_map[hid] = i ; 
          auto h = ev_hit->at(hid);

          if ( tot_mc_cw_hits_v.find(i) == tot_mc_cw_hits_v.end() )
            tot_mc_cw_hits_v[i] = h.Integral() ;
          else
            tot_mc_cw_hits_v[i] += h.Integral() ;
           
        }
      }
      // Now we have a map of gaushits to corresponding mccluster

      // Find the gaushits that correspond to the tagged track associated hits
      // This particular headache is necessary because there are no gaushit associations
      // to pandoraNu tracks, only pandoraNuCosmicRemoval associations. 
      // We're using gaushit for everything else including clustering + mccluster building though,
      // so need to find the gaushits that correspond to the cosmic removal hits 
      // and store these IDs for backtracker to work.
      std::vector<int> tag_trk_gaushit_v;
      for(int i = 0; i < ass_hit_v.at(min_trk_dist_it).size(); i++){
         auto hid = ass_hit_v.at(min_trk_dist_it).at(i) ;
         auto h = ev_hit_cosRem->at(hid);
         if ( h.WireID().Plane != 2 ) continue;

         for(int j = 0; j < ev_hit->size(); j++){
           auto hj = ev_hit->at(j) ; 
           if ( hj.WireID().Plane != 2 ) continue;

           if ( hj.PeakTime() == h.PeakTime() && hj.WireID().Wire == h.WireID().Wire )
             tag_trk_gaushit_v.emplace_back(j);
         }
      }
      // Now we also have the gaushits that correspond to the TAGGED track

      pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;
      cw_pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;

      int max_hits = -1;
      int max_cw_hits = -1;
      int max_cid = -1 ;
      float tot_reco_cw_hits = 0;

      // For each reco cluster, find the origin of all hits and calc purity/completeness 
      // the "...size()+1" is to account for noise category
      for(int i = 0; i < tag_trk_gaushit_v.size(); i++){
         auto hid = tag_trk_gaushit_v.at(i) ;
         auto h = ev_hit->at(hid);

         if ( h.WireID().Plane != 2 ) continue;

         tot_reco_cw_hits += h.Integral() ;
         
         if ( _mc_hit_map.find(hid) != _mc_hit_map.end() ){

           auto mcclus_id = _mc_hit_map[hid] ;

           pur_ctr_v[mcclus_id]++ ; 
           cw_pur_ctr_v[mcclus_id] += h.Integral() ; 

           if( pur_ctr_v[mcclus_id] > max_hits ){
            
             max_hits = pur_ctr_v[mcclus_id];
             max_cid = mcclus_id ; 
             max_cw_hits = cw_pur_ctr_v[mcclus_id] ;
           }
         }
         else {
           // our "else" here is to account for noise category in which there is no corresponding true charge
           auto mcclus_id = ass_mcclus_v.size() ;
           pur_ctr_v[mcclus_id]++ ; 
           cw_pur_ctr_v[mcclus_id] += h.Integral() ; 
           if( pur_ctr_v[mcclus_id] > max_hits ){
            
             max_hits = pur_ctr_v[mcclus_id];
             max_cid = mcclus_id ; 
             max_cw_hits = cw_pur_ctr_v[mcclus_id] ;
           }
         }
       }

       if ( max_cid != ass_mcclus_v.size() && max_cid != -1 ){

         auto tot_mc_hits =  ass_mcclus_v[max_cid].size(); 
         auto tot_reco_hits = tag_trk_gaushit_v.size() ; 
         _mu_purity   = float(max_hits) / tot_reco_hits ;
         _mu_complete = float(max_hits) / tot_mc_hits ;
         _mu_cw_purity   = float(max_cw_hits) / tot_reco_cw_hits ;
         _mu_cw_complete = float(max_cw_hits) / tot_mc_cw_hits_v[max_cid]; 
       }
       else {
         // Noise category
         _n_noise++;
         _bkgd_id = 0 ;
         _event_list.emplace_back(_event) ;
       }

      ///////////////////////////////////////////////////////////////////////////////////////////////
      /// Now count the number of backgrounds and signals
      ///////////////////////////////////////////////////////////////////////////////////////////////
      if( _bkgd_id == -1 ){

        // 0) In FV?
        bool infv = true;
        if( mc_vtx_x < 20 || mc_vtx_x > 236.35 || mc_vtx_y > 96.5 || mc_vtx_y < -96.5 || mc_vtx_z < 10 || mc_vtx_z > 1026.8 )
          infv = false;

        // 1) How many GENIE-level pi0s or gammas do we observe?
        auto parts = ev_mctruth->at(0).GetParticles();
        int n_pi0 = 0;
        int n_gamma = 0;

        for ( auto const & p : parts ){
          if( p.StatusCode() == 1 && p.PdgCode() == 111 )
            n_pi0++;

          if( p.StatusCode() == 1 && p.PdgCode() == 22 )
            n_gamma++;
        }   

        // Get true opening angle of pi0s for relevant events
        int n_shr_111 = 0; 
        std::vector<int> shr_it_v ;
        for ( int si = 0; si < ev_mcs->size(); si++ ){
          auto s = ev_mcs->at(si) ; 
          if ( n_pi0 == 1 && s.MotherPdgCode() == 111 && s.AncestorPdgCode() == 111 && s.Origin() == 1 && s.PdgCode() == 22){
            n_shr_111++ ;
            shr_it_v.emplace_back(si);
          }
	  // For reco efficiency studies
          if ( (s.PdgCode() == 22 && s.MotherPdgCode() == 111 && s.AncestorPdgCode() == 111 && s.Origin() == 1 ) ||
	       (s.PdgCode() == 22 && s.AncestorPdgCode() == 22 && s.Origin() == 1 ) ||
	       (s.PdgCode() == 11 && s.AncestorPdgCode() == 11 && s.Origin() == 1 ) ){
	    _n_mcs_at_vtx++ ;
            all_mcs_v.emplace_back(si);
	  }
        } 
        if ( n_shr_111 == 2 ){ 
          auto s0 = ev_mcs->at(shr_it_v.at(0));
          auto s1 = ev_mcs->at(shr_it_v.at(1));
          auto m0 = s0.Start().Momentum() ;
          auto m1 = s1.Start().Momentum() ;
          auto dot = TMath::Cos(m0.Angle(m1.Vect())); 
          _pi0_true_oangle = acos(dot)  ;
  	}

       // 2) What is the origin of the muon track (neutrino or cosmic)?
       auto mcclus = ev_mcc->at(max_cid) ;
       _mu_type   = mcclus.StartOpeningAngle() ; // Opening angle set to track (0) or shower(1) in mccluster builder
       auto ts_index = mcclus.Width() ;          // Width set to carry producer mctrack/mcshower index

       if( _mu_type == 0 ){
         auto mct = ev_mct->at(ts_index) ;
         _mu_origin = mct.Origin(); 
         _mu_mother_pdg = mct.MotherPdgCode();
         _mu_pdg = mct.PdgCode();
	 _mu_true_angle = mct.Start().Momentum().Theta() ;
	 _mu_true_phi = mct.Start().Momentum().Phi() ;
	 _mu_true_mom = mct.Start().Momentum().P() ;
	 _mu_true_startx = mct.Start().X(); 
	 _mu_true_starty = mct.Start().Y(); 
	 _mu_true_startz = mct.Start().Z(); 
	 _mu_true_endx = mct.End().X() ;
	 _mu_true_endy = mct.End().Y() ;
	 _mu_true_endz = mct.End().Z() ;
       }
       else{
         auto mcs = ev_mcs->at(ts_index) ;
         _mu_origin = ev_mcs->at(ts_index).Origin(); 
         _mu_mother_pdg = mcs.MotherPdgCode();
         _mu_pdg = mcs.PdgCode();
       }

        // Assign preliminary background categories based on checks 0)-2)
        if( _mu_origin == 2){
          _n_cosmic++;
          _bkgd_id = 1; 
        }
        else if( abs(nu.Nu().PdgCode()) == 12 ){
          _n_nue ++ ; 
          _bkgd_id = 6 ;
        }
        else if( nu.Nu().PdgCode() == -14 ){
          _n_antimu ++ ; 
          _bkgd_id = 7 ;
        }
        // From here we can assume we have a muon neutrino
        else if( nu.Nu().PdgCode() == 14 && n_pi0 == 1 && nu.CCNC() == 0 && infv){
          _bkgd_id = 2; // this is signal
          _n_cc1pi0++; 
        }
        else if( nu.CCNC() == 1 && n_pi0 > 0 ) {
          _bkgd_id = 3;
          _n_nc1pi0 ++; 
        }
        else if ( nu.CCNC() == 0 && n_pi0 == 1 && !infv ){
          _bkgd_id = 4 ;
          _n_cc1pi0_outFV ++; 
        }
        else if( nu.CCNC() == 0 && n_pi0 > 1 ) {
          _bkgd_id = 5;
          _n_multpi0 ++; 
        }
        else if( n_pi0 == 0 && n_gamma > 0 ){
          if ( n_gamma  == 1 )
            _1gamma++;

          _bkgd_id = 10 ;
          _n_gamma++;
        }
        else{
          // 3) If still haven't assigned a category, check Geant4 level processes that occur outside vertex 
          bool charge_ex = false; 
          bool kaon_decay = false; 
          for ( auto const & s : *ev_mcs ){
            if ( s.MotherPdgCode() == 111 && s.Origin() == 1 && abs(s.AncestorPdgCode()) == 211 ){
              charge_ex = true; 
              break;
            }
            if ( s.MotherPdgCode() == 111 && s.Origin() == 1 && abs(s.AncestorPdgCode()) == 321 ){
              kaon_decay = true; 
              break;
            }
          }

          if( charge_ex && nu.CCNC() == 0 ){
            _bkgd_id = 8;
            _n_cccex++;
          }
          else if( charge_ex && nu.CCNC() == 1 ) {
            _bkgd_id = 9;
            _n_nccex++;
          }
          else if( kaon_decay ){
            _bkgd_id = 11;
            _n_kaondecay++;
          }
          else if( !charge_ex && nu.CCNC() == 0 ){
            _bkgd_id = 12;
            _n_ccother++; 

          }
          else if( !charge_ex && nu.CCNC() == 1 ){
            _bkgd_id = 13;
            _n_ncother++; 
          }
          else {
            _bkgd_id = 14;
            _n_other ++;   
          }
        }
      }

      // Get the association from cluster -> hit
      auto const & ev_clus = storage->get_data<event_cluster>("ImageClusterHit");
      auto const & ev_ass_c = storage->get_data<larlite::event_ass>("ImageClusterHit");
      auto const & ass_imageclus_v = ev_ass_c->association(ev_clus->id(), ev_hit->id());

      // Now fill TRUTH pi0 info if user indicates interest -- note we are still in the MC if statement
      if ( _get_pi0_info ){

        // "pi0_candidate_showers" are created by the filter that identifies the final sample of pi0 candidates
        auto ev_s = storage->get_data<event_shower>("pi0_candidate_showers");
        if( !ev_s || !ev_s->size() ){ 
          std::cout<<"Not enough reco'd showers..." <<std::endl;
          return false;
         }   

        auto const& shr1 = ev_s->at(0) ;
        auto const& shr2 = ev_s->at(1);
        bool lowE_is_shr1 = shr1.Energy(2) < shr2.Energy(2) ? 1 : 0 ;

        // Get the association from shower -> cluster
        auto ev_ass_s = storage->get_data<larlite::event_ass>("pi0_candidate_showers");
        auto const& ass_showerreco_v = ev_ass_s->association(ev_s->id(), ev_clus->id());
        
        // Loop over pi0 candidate showers to fill a bunch of info!
        for (size_t i = 0; i < ass_showerreco_v.size(); i++ ){

          float purity = 0., complete = 0., cw_purity = 0., cw_complete = 0.;
	  float pi0_origin = -1, pi0_type = -1 ;
          int ts_index = -1 ;

          // Loop over clusters associated to this pi0 candidate shower
          for (size_t j = 0; j < ass_showerreco_v.at(i).size(); j++ ){

            auto clus_id = ass_showerreco_v.at(i).at(j); 
            auto iclus = ev_clus->at(clus_id);
          
            // Only consider clusters in plane 2
            int plane = iclus.Plane().Plane ;
            if ( plane != 2 ) continue;

            pur_ctr_v.clear();
            cw_pur_ctr_v.clear();
            pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;
            cw_pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;
            max_hits = -1;
            max_cw_hits = -1;
            max_cid = -1 ;
            tot_reco_cw_hits = 0;

            // Loop through all hits associared to this plane 2 pi0 candidate cluster 
	    // Calculate info for pur + completeness similar to muon above
            for ( int k = 0; k < ass_imageclus_v.at(clus_id).size(); k++ ){

              auto hid = ass_imageclus_v.at(clus_id).at(k) ; 
              auto h = ev_hit->at(hid);
              tot_reco_cw_hits += h.Integral() ;
              
              if ( _mc_hit_map.find(hid) != _mc_hit_map.end() ){

                auto mcclus_id = _mc_hit_map[hid] ;

                pur_ctr_v[mcclus_id]++ ; 
                cw_pur_ctr_v[mcclus_id] += h.Integral() ; 

                if( pur_ctr_v[ mcclus_id] > max_hits ){
                  max_hits = pur_ctr_v[mcclus_id];
                  max_cid = mcclus_id ; 
                  max_cw_hits = cw_pur_ctr_v[mcclus_id] ;
                }
              }
	      else {
	        auto mcclus_id = ass_mcclus_v.size() ;
                pur_ctr_v[mcclus_id]++ ; 
                cw_pur_ctr_v[mcclus_id] += h.Integral() ; 
                if( pur_ctr_v[mcclus_id] > max_hits ){
                  max_hits = pur_ctr_v[mcclus_id];
                  max_cid = mcclus_id ; 
                  max_cw_hits = cw_pur_ctr_v[mcclus_id] ;
                }
	      }
            }

            auto clocktick = larutil::DetectorProperties::GetME()->SamplingRate() * 1.e-3; //time sample in us
            float mc_clus_e = -999.;
	     
            // If there is a corresponding mccluster to this group of hits, fill stuff!
            if ( max_cid != ass_mcclus_v.size() && max_cid != -1){

              auto tot_mc_hits =  ass_mcclus_v[max_cid].size(); 
              auto tot_reco_hits = ass_imageclus_v[clus_id].size();
              
              purity   = float(max_hits) / tot_reco_hits ;
              complete = float(max_hits) / tot_mc_hits ;
              cw_purity   = float(max_cw_hits) / tot_reco_cw_hits ;
              cw_complete = float(max_cw_hits) / tot_mc_cw_hits_v[max_cid]; 

              auto mcclus = ev_mcc->at(max_cid) ;
              ts_index = mcclus.Width();            // width set to carry mct/s index
              pi0_type   = mcclus.StartOpeningAngle() ; // opening angle set to track (0) or shower(1) in mccluster builder

              if( pi0_type == 0 )
                pi0_origin = ev_mct->at(ts_index).Origin(); 
              else{
                auto mcs = ev_mcs->at(ts_index) ;
                pi0_origin = mcs.Origin(); 
              }

              mc_clus_e = 0;

	      // Fill perfect clustering info for the mccluster corresponding to true
              for ( auto const & mcc_hid : ass_mcclus_v[max_cid] ){
                auto mch = ev_hit->at(mcc_hid) ;
                float lifetime_corr = exp( mch.PeakTime() * clocktick / _lifetime_corr) ; //1.e20);
                float electrons = mch.Integral() * _gain; // mcc8 value
                float dQ = electrons * lifetime_corr * 23.6 * 1e-6 ;
                float dE = dQ / _recomb ; // recomb factor
                mc_clus_e += dE ;
              }   
            }

            auto ishr = ev_s->at(i);

            if ( i == 0 ){
              if ( lowE_is_shr1 ){ 
                _pi0_low_purity = purity ;
                _pi0_low_complete = complete;
	        _pi0_low_st_x = ishr.ShowerStart().X();
	        _pi0_low_st_y = ishr.ShowerStart().Y();
	        _pi0_low_st_z = ishr.ShowerStart().Z();
	        _pi0_low_origin = pi0_origin;
	        _pi0_low_type = pi0_type;
		_pi0_low_perfect_clustering_E = mc_clus_e ;

                if ( ts_index != -1 ){
                  _pi0_low_mother_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).MotherPdgCode() : ev_mct->at(ts_index).MotherPdgCode() ; 
                  _pi0_low_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).PdgCode() : ev_mct->at(ts_index).PdgCode() ; 
	          _pi0_low_from_pi0 = _pi0_low_mother_pdg == 111 ? 1 : 0 ;
		}

	        if ( _pi0_low_type == 1 ){
                  auto mcs = ev_mcs->at(ts_index) ;
	          _pi0_low_true_st_x = mcs.Start().X() ;
	          _pi0_low_true_st_y = mcs.Start().Y() ;
	          _pi0_low_true_st_z = mcs.Start().Z() ;
	          _pi0_low_true_detProf_st_x = mcs.DetProfile().X() ;
	          _pi0_low_true_detProf_st_y = mcs.DetProfile().Y() ;
	          _pi0_low_true_detProf_st_z = mcs.DetProfile().Z() ;

	          _pi0_low_true_gammaE = mcs.Start().E() ;
                  _pi0_low_true_detProf_gammaE = mcs.DetProfile().E() ;
	        }
              }
              else{
                _pi0_high_purity = purity;
                _pi0_high_complete = complete;
	        _pi0_high_st_x = ishr.ShowerStart().X();
	        _pi0_high_st_y = ishr.ShowerStart().Y();
	        _pi0_high_st_z = ishr.ShowerStart().Z();
	        _pi0_high_origin = pi0_origin;
	        _pi0_high_type = pi0_type;
		_pi0_high_perfect_clustering_E = mc_clus_e ;

                if ( ts_index != -1 ){
                  _pi0_high_mother_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).MotherPdgCode() : ev_mct->at(ts_index).MotherPdgCode() ; 
                  _pi0_high_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).PdgCode() : ev_mct->at(ts_index).PdgCode() ; 
	          _pi0_high_from_pi0 = _pi0_high_mother_pdg == 111 ? 1 : 0 ;
	        }

	        if ( _pi0_high_type == 1){
                  auto mcs = ev_mcs->at(ts_index) ;
	          _pi0_high_true_st_x = mcs.Start().X() ;
	          _pi0_high_true_st_y = mcs.Start().Y() ;
	          _pi0_high_true_st_z = mcs.Start().Z() ;
	          _pi0_high_true_detProf_st_x = mcs.DetProfile().X() ;
	          _pi0_high_true_detProf_st_y = mcs.DetProfile().Y() ;
	          _pi0_high_true_detProf_st_z = mcs.DetProfile().Z() ;
	          _pi0_high_true_gammaE = mcs.Start().E() ;
                  _pi0_high_true_detProf_gammaE = mcs.DetProfile().E() ;
	        }
              }
            }
            else if ( i == 1) {

              if ( !lowE_is_shr1 ){ 
                _pi0_low_purity = purity ;
                _pi0_low_complete = complete;
	        _pi0_low_st_x = ishr.ShowerStart().X();
	        _pi0_low_st_y = ishr.ShowerStart().Y();
	        _pi0_low_st_z = ishr.ShowerStart().Z();
	        _pi0_low_origin = pi0_origin;
	        _pi0_low_type = pi0_type;
		_pi0_low_perfect_clustering_E = mc_clus_e ;

                if ( ts_index != -1 ){
                  //std::cout<<"ts_index: "<<ts_index<<", "<<ev_mcs->size()<<", "<<ev_mct->size()<<std::endl;
                  _pi0_low_mother_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).MotherPdgCode() : ev_mct->at(ts_index).MotherPdgCode() ; 
                  _pi0_low_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).PdgCode() : ev_mct->at(ts_index).PdgCode() ; 
	          _pi0_low_from_pi0 = _pi0_low_mother_pdg == 111 ? 1 : 0 ;
		}

	        if ( _pi0_low_type == 1 ){
                  auto mcs = ev_mcs->at(ts_index) ;
	          _pi0_low_true_st_x = mcs.Start().X() ;
	          _pi0_low_true_st_y = mcs.Start().Y() ;
	          _pi0_low_true_st_z = mcs.Start().Z() ;
	          _pi0_low_true_detProf_st_x = mcs.DetProfile().X() ;
	          _pi0_low_true_detProf_st_y = mcs.DetProfile().Y() ;
	          _pi0_low_true_detProf_st_z = mcs.DetProfile().Z() ;
	          _pi0_low_true_gammaE = mcs.Start().E() ;
                  _pi0_low_true_detProf_gammaE = mcs.DetProfile().E() ;
	        }
             }
             else{

               _pi0_high_purity = purity;
               _pi0_high_complete = complete;
	       _pi0_high_st_x = ishr.ShowerStart().X();
	       _pi0_high_st_y = ishr.ShowerStart().Y();
	       _pi0_high_st_z = ishr.ShowerStart().Z();
	       _pi0_high_origin = pi0_origin;
	       _pi0_high_type = pi0_type;
	       _pi0_high_perfect_clustering_E = mc_clus_e ;

               if ( ts_index != -1 ){
                 _pi0_high_mother_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).MotherPdgCode() : ev_mct->at(ts_index).MotherPdgCode() ; 
                 _pi0_high_pdg = pi0_type == 1 ? ev_mcs->at(ts_index).PdgCode() : ev_mct->at(ts_index).PdgCode() ; 
	         _pi0_high_from_pi0 = _pi0_high_mother_pdg == 111 ? 1 : 0 ;
	       }

	       if ( _pi0_high_type == 1){
                 auto mcs = ev_mcs->at(ts_index) ;
	         _pi0_high_true_st_x = mcs.Start().X() ;
	         _pi0_high_true_st_y = mcs.Start().Y() ;
	         _pi0_high_true_st_z = mcs.Start().Z() ;
	         _pi0_high_true_detProf_st_x = mcs.DetProfile().X() ;
	         _pi0_high_true_detProf_st_y = mcs.DetProfile().Y() ;
	         _pi0_high_true_detProf_st_z = mcs.DetProfile().Z() ;
	         _pi0_high_true_gammaE = mcs.Start().E() ;
                 _pi0_high_true_detProf_gammaE = mcs.DetProfile().E() ;
	       }
             }
           }

           auto sce_corr_l = _SCE->GetPosOffsets(_pi0_low_true_st_x,_pi0_low_true_st_y,_pi0_low_true_st_z);
           auto sce_corr_h = _SCE->GetPosOffsets(_pi0_high_true_st_x,_pi0_high_true_st_y,_pi0_high_true_st_z);

           _pi0_low_true_scecorr_st_x = _pi0_low_true_st_x + vtxtimecm + 0.7 - sce_corr_l.at(0);
           _pi0_low_true_scecorr_st_y = _pi0_low_true_st_y + sce_corr_l.at(1);
           _pi0_low_true_scecorr_st_z = _pi0_low_true_st_z + sce_corr_l.at(2);
           
           _pi0_high_true_scecorr_st_x = _pi0_high_true_st_x + vtxtimecm + 0.7 - sce_corr_h.at(0);
           _pi0_high_true_scecorr_st_y = _pi0_high_true_st_y + sce_corr_h.at(1);
           _pi0_high_true_scecorr_st_z = _pi0_high_true_st_z + sce_corr_h.at(2);

         }
       } // Loop over candidate pi0 showers
       if ( _bkgd_id == 2 && _pi0_low_origin != 2 && _pi0_high_origin != 2 ){
         _signal = true;
         _n_signals++;
       }
     }

     if ( _get_single_shower_info ){

       auto ev_s = storage->get_data<event_shower>("pi0_1gamma_candidate_showers");
       if ( !ev_s ) return false;

       // Get the association from shower -> cluster
       auto ev_ass_s = storage->get_data<larlite::event_ass>("pi0_1gamma_candidate_showers");
       auto const& ass_showerreco_v = ev_ass_s->association(ev_s->id(), ev_clus->id());

       // Loop over clusters associated to this single shower sample candidate shower
       for (size_t j = 0; j < ass_showerreco_v.at(0).size(); j++ ){

         auto clus_id = ass_showerreco_v.at(0).at(j); 
         auto iclus = ev_clus->at(clus_id);
         
         int plane = iclus.Plane().Plane ;
         if ( plane != 2 ) continue;

         pur_ctr_v.clear();
         cw_pur_ctr_v.clear();
         pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;
         cw_pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;

         max_hits = -1;
         max_cw_hits = -1;
         max_cid = -1 ;
         tot_reco_cw_hits = 0;
         
         // Loop through all hits associared to the cluster 
         for ( int k = 0; k < ass_imageclus_v.at(clus_id).size(); k++ ){

           auto hid = ass_imageclus_v.at(clus_id).at(k) ; 
           auto h = ev_hit->at(hid);
           tot_reco_cw_hits += h.Integral() ;
           
           if ( _mc_hit_map.find(hid) != _mc_hit_map.end() ){

             auto mcclus_id = _mc_hit_map[hid] ;

             pur_ctr_v[mcclus_id]++ ; 
             cw_pur_ctr_v[mcclus_id] += h.Integral() ; 

             if( pur_ctr_v[ mcclus_id] > max_hits ){
               max_hits = pur_ctr_v[mcclus_id];
               max_cid = mcclus_id ; 
               max_cw_hits = cw_pur_ctr_v[mcclus_id] ;
             }
           }
           else {
             auto mcclus_id = ass_mcclus_v.size() ;
             pur_ctr_v[mcclus_id]++ ; 
             cw_pur_ctr_v[mcclus_id] += h.Integral() ; 
             if( pur_ctr_v[mcclus_id] > max_hits ){
               max_hits = pur_ctr_v[mcclus_id];
               max_cid = mcclus_id ; 
               max_cw_hits = cw_pur_ctr_v[mcclus_id] ;
             }
           }
         }

         auto clocktick = larutil::DetectorProperties::GetME()->SamplingRate() * 1.e-3; //time sample in us
         float mc_clus_e = -999.;

         if ( max_cid != ass_mcclus_v.size() && max_cid != -1){

           auto tot_mc_hits =  ass_mcclus_v[max_cid].size(); 
           auto tot_reco_hits = ass_imageclus_v[clus_id].size();
           
           _gamma_purity   = float(max_hits) / tot_reco_hits ;
           _gamma_complete = float(max_hits) / tot_mc_hits ;
           _gamma_cw_purity   = float(max_cw_hits) / tot_reco_cw_hits ;
           _gamma_cw_complete = float(max_cw_hits) / tot_mc_cw_hits_v[max_cid]; 

           auto mcclus = ev_mcc->at(max_cid) ;
           _gamma_type   = mcclus.StartOpeningAngle() ; // opening angle set to track (0) or shower(1) in mccluster builder
           int gamma_index = mcclus.Width();            // width set to carry mct/s index
	   float gamma_ancestor_pdg = -1;

           if( _gamma_type == 0 ){
             auto mct = ev_mct->at(gamma_index) ;
             _gamma_origin = mct.Origin(); 
             _gamma_mother_pdg = mct.MotherPdgCode() ; 
             _gamma_pdg = mct.PdgCode() ; 
           }
           else{
             auto mcs = ev_mcs->at(gamma_index) ;
             _gamma_origin = mcs.Origin(); 
             _gamma_mother_pdg = mcs.MotherPdgCode() ; 
             gamma_ancestor_pdg = mcs.AncestorPdgCode() ; 
             _gamma_pdg = mcs.PdgCode() ; 
             _gamma_from_pi0 = _gamma_mother_pdg == 111 ? 1 : 0 ;
             _gamma_trueE_detProf = mcs.DetProfile().E();
             _gamma_trueE = mcs.Start().E() ;
	     _gamma_true_detProf_startx = mcs.DetProfile().X() ;
	     _gamma_true_detProf_starty = mcs.DetProfile().Y() ;
	     _gamma_true_detProf_startz = mcs.DetProfile().Z() ;
	     _gamma_true_startx = mcs.Start().X() ;
	     _gamma_true_starty = mcs.Start().Y() ;
	     _gamma_true_startz = mcs.Start().Z() ;
           }

	   if ( _gamma_origin == 1 && ( gamma_ancestor_pdg == 111 || gamma_ancestor_pdg == 22 || gamma_ancestor_pdg == 11) )
	     _n_reco_at_vtx++ ;

           if ( _bkgd_id == 2 && _gamma_origin != 2 ){
             _n_signals++;
             _signal = true;
           }

           mc_clus_e = 0;

	   // Fill perfect clustering info for the mccluster corresponding to true
           for ( auto const & mcc_hid : ass_mcclus_v[max_cid] ){
             auto mch = ev_hit->at(mcc_hid) ;
             float lifetime_corr = exp( mch.PeakTime() * clocktick / _lifetime_corr );
             float electrons = mch.Integral() * _gain; //mcc8 value
             float dQ = electrons * lifetime_corr * 23.6 * 1e-6 ;
             float dE = dQ / _recomb ; // recomb factor
             mc_clus_e += dE ;
           }   

           _gamma_perfect_clustering_E = mc_clus_e ;
         } // If we've found a matching mccluster
       } // Find plane 2 candidate single shower
     } // if we're filling single shower info
   } // if we're filling MC truth info


   // Now that we've filled truth info, also fill reco info that we need from both MC and data
   if ( _get_pi0_info ){

     auto ev_s = storage->get_data<event_shower>("pi0_candidate_showers");
     if( !ev_s || !ev_s->size() ){
       std::cout<<"Not enough reco'd showers..." <<std::endl;
       return false;
     }   

     auto const& shr1 = ev_s->at(0) ;
     auto const& shr2 = ev_s->at(1);

     geoalgo::Vector_t rev_shr1(-1.*shr1.Direction()) ;
     geoalgo::Vector_t rev_shr2(-1.*shr2.Direction()) ;

     // Make the backwards projection for the showers
     auto shr1_bkwrd_hl = ::geoalgo::HalfLine_t(shr1.ShowerStart(),rev_shr1);
     auto shr2_bkwrd_hl = ::geoalgo::HalfLine_t(shr2.ShowerStart(),rev_shr2);

     ::geoalgo::Point_t temp_vertex(vtx.X(),vtx.Y(),vtx.Z());
     auto shr1_IP_w_vtx = _geoAlgo.SqDist(temp_vertex, shr1_bkwrd_hl) ;
     auto shr2_IP_w_vtx = _geoAlgo.SqDist(temp_vertex, shr2_bkwrd_hl) ;
     auto IP = pow(_geoAlgo.SqDist(shr1_bkwrd_hl,shr2_bkwrd_hl),0.5);

     // Opening angle of the showers
     double oangle = acos( shr1.Direction().Dot(shr2.Direction())) ;

     // Vertex point of the two showers. the true designated backwards project
     geoalgo::Point_t vertex(3);

     auto st1 = shr1.ShowerStart();
     auto st2= shr2.ShowerStart();
     auto dir1 = shr1.Direction();
     auto dir2 = shr2.Direction();
     geoalgo::HalfLine_t shr1_hl(st1.X(),st1.Y(),st1.Z(),dir1.X(),dir1.Y(), dir1.Z() );
     geoalgo::HalfLine_t shr2_hl(st2.X(),st2.Y(),st2.Z(),dir2.X(),dir2.Y(), dir2.Z() );

     _geoAlgo.commonOrigin(shr1_hl, shr2_hl, vertex, true);

     // CCNC Diretion of two correlated shower
     geoalgo::Vector_t momentum(3);// need to fill out
     geoalgo::Vector_t mom_vect(shr2.Direction()*shr2.Energy(2) + shr1.Direction()*shr1.Energy(2)) ;

     auto tot_pi0_mom = sqrt(pow(mom_vect[0],2) + pow(mom_vect[1],2) + pow(mom_vect[2],2) );
     auto radL_shr1 = temp_vertex.Dist(shr1.ShowerStart());
     auto radL_shr2 = temp_vertex.Dist(shr2.ShowerStart());

     _pi0_mass      = sqrt(2 * shr1.Energy(2) * shr2.Energy(2) *(1.-cos(oangle)));
     _pi0_mom       = tot_pi0_mom;
     _pi0_oangle    = oangle;
     _pi0_IP        = IP ;
     _pi0_low_reco_gammaE  = shr1.Energy(2) < shr2.Energy(2) ? shr1.Energy(2) : shr2.Energy(2) ;
     _pi0_high_reco_gammaE = shr1.Energy(2) < shr2.Energy(2) ? shr2.Energy(2) : shr1.Energy(2) ;
     _pi0_low_radL  = shr1.Energy(2) < shr2.Energy(2) ? radL_shr1 : radL_shr2 ;
     _pi0_high_radL = shr1.Energy(2) < shr2.Energy(2) ? radL_shr2 : radL_shr1 ;
     _pi0_high_IP_w_vtx = shr1.Energy(2) < shr2.Energy(2) ? shr2_IP_w_vtx : shr1_IP_w_vtx ;
     _pi0_low_IP_w_vtx  = shr1.Energy(2) < shr2.Energy(2) ? shr1_IP_w_vtx : shr2_IP_w_vtx ;

     _pi0_low_st_x = shr1.Energy(2) < shr2.Energy(2) ? shr1.ShowerStart().X(): shr2.ShowerStart().X() ;
     _pi0_low_st_y = shr1.Energy(2) < shr2.Energy(2) ? shr1.ShowerStart().Y(): shr2.ShowerStart().Y() ;
     _pi0_low_st_z = shr1.Energy(2) < shr2.Energy(2) ? shr1.ShowerStart().Z(): shr2.ShowerStart().Z() ;
     _pi0_high_st_x = shr1.Energy(2) < shr2.Energy(2) ? shr2.ShowerStart().X(): shr1.ShowerStart().X();
     _pi0_high_st_y = shr1.Energy(2) < shr2.Energy(2) ? shr2.ShowerStart().Y(): shr1.ShowerStart().Y();
     _pi0_high_st_z = shr1.Energy(2) < shr2.Energy(2) ? shr2.ShowerStart().Z(): shr1.ShowerStart().Z();

     auto pz1 = shr1.Direction()*shr1.Energy(2) ;
     auto pz2 = shr2.Direction()*shr2.Energy(2) ;

     _pi0_low_mom_x = shr1.Energy(2) < shr2.Energy(2) ? pz1[0] : pz2[0] ;
     _pi0_high_mom_x = shr1.Energy(2) < shr2.Energy(2) ? pz2[0] : pz1[0] ;
     _pi0_low_mom_y = shr1.Energy(2) < shr2.Energy(2) ? pz1[1] : pz2[1] ;
     _pi0_high_mom_y = shr1.Energy(2) < shr2.Energy(2) ? pz2[1] : pz1[1] ;
     _pi0_low_mom_z = shr1.Energy(2) < shr2.Energy(2) ? pz1[2] : pz2[2] ;
     _pi0_high_mom_z = shr1.Energy(2) < shr2.Energy(2) ? pz2[2] : pz1[2] ;


   }
 
   if ( _get_single_shower_info ){

     auto ev_s = storage->get_data<event_shower>("pi0_1gamma_candidate_showers");
     if ( !ev_s ) return false;

     _gamma_startx = ev_s->at(0).ShowerStart().X();
     _gamma_starty = ev_s->at(0).ShowerStart().Y();
     _gamma_startz = ev_s->at(0).ShowerStart().Z();

     geoalgo::Point_t vertex(3);
     vertex[0] = vtx.X();
     vertex[1] = vtx.Y();
     vertex[2] = vtx.Z();

     geoalgo::Vector_t rev_shr1(-1.*ev_s->at(0).Direction()) ;
     auto shr1_bkwrd_hl = ::geoalgo::HalfLine_t(ev_s->at(0).ShowerStart(),rev_shr1);

     _gamma_E = ev_s->at(0).Energy(2); 
     _gamma_RL = vertex.Dist(ev_s->at(0).ShowerStart());
     _gamma_IP_w_vtx = _geoAlgo.SqDist(vertex, shr1_bkwrd_hl) ;
   }

   // Count number of showers with non-zero energy
   if ( ev_shr ){ 
     int shr_it = 0;
     for ( auto const & s : *ev_shr ){ if ( s.Energy(2) > 1e-30 ) shr_it++ ; } 
     _nshrs = shr_it;
   } 

   // This is for showerrreco efficiency plots
   std::vector<int> used_mcs_v ;
     
   // Fill info per shower
   if ( ev_shr->size() != 0 ){
     auto geomH = ::larutil::GeometryHelper::GetME();

     auto const & ev_clus = storage->get_data<event_cluster>("ImageClusterHit");
     auto const & ev_ass_c = storage->get_data<larlite::event_ass>("ImageClusterHit");
     auto const & ass_imageclus_v = ev_ass_c->association(ev_clus->id(), ev_hit->id());

     auto ev_ass_s = storage->get_data<larlite::event_ass>("showerreco");
     auto const& ass_showerreco_v = ev_ass_s->association(ev_shr->id(), ev_clus->id());

     // Loop over all showers in this event
     //std::cout<<" ass shower size: "<<ass_showerreco_v.size() <<", "<<ev_shr->size()<<std::endl ;
     for (size_t i = 0; i < ass_showerreco_v.size(); i++ ){
       
       shower_clear();

       auto s = ev_shr->at(i);
       if ( s.Energy(2) <= 1e-30 ){ continue ; }
           
       _shr_startx = s.ShowerStart().X();
       _shr_starty = s.ShowerStart().Y();
       _shr_startz = s.ShowerStart().Z();

       std::vector<float> shr_to_proj = { _shr_startx, _shr_starty, _shr_startz } ;
       auto shr2d = geomH->Point_3Dto2D(shr_to_proj,2) ;
       _shr_startw = shr2d.w ;
       _shr_startt = shr2d.t ;

       _shr_dirx = s.Direction().X();
       _shr_diry = s.Direction().Y();
       _shr_dirz = s.Direction().Z();

       _shr_energy = s.Energy(2);
       _shr_oangle = s.OpeningAngle();
       _shr_dedx = s.dEdx(2);

       _shr_vtx_dist = sqrt( pow(_vtx_x - _shr_startx,2) + pow(_vtx_y - _shr_starty,2) + pow(_vtx_z - _shr_startz,2) ); 
       _shr_trk_delta_theta = s.Direction().Theta() - _mu_angle;
       _shr_trk_delta_phi = s.Direction().Phi() - _mu_phi ;

       geoalgo::Point_t vertex(3);
       vertex[0] = vtx.X();
       vertex[1] = vtx.Y();
       vertex[2] = vtx.Z();

       geoalgo::Vector_t rev_shr1(-1.*s.Direction()) ;
       auto shr1_bkwrd_hl = ::geoalgo::HalfLine_t(s.ShowerStart(),rev_shr1);
       _shr_ip = _geoAlgo.SqDist(vertex, shr1_bkwrd_hl) ;

       if ( _mc_sample ) {

         auto ev_mct = storage->get_data<event_mctrack>("mcreco");
         if ( !ev_mct || !ev_mct->size() ) {std::cout<<"No MCTrack!" <<std::endl ; return false; }

         auto ev_mcs = storage->get_data<event_mcshower>("mcreco") ;
         if ( !ev_mcs || !ev_mcs->size() ) {std::cout<<"No MCShower!" <<std::endl ; return false; }

         // Now get Mccluster info
         auto ev_ass = storage->get_data<larlite::event_ass>("mccluster");
         auto const& ass_keys = ev_ass->association_keys();

         if ( ass_keys.size() == 0 ) return false; 

         larlite::event_cluster *ev_mcclus = nullptr;
         auto ass_hit_clus_v = storage->find_one_ass( ass_keys[0].first, ev_mcclus, ev_ass->name() );

         larlite::event_hit *ev_mchit = nullptr;
         auto ass_mcclus_v = storage->find_one_ass( ass_keys[0].second, ev_mchit, ev_ass->name() );

         auto ev_mcc = storage->get_data<event_cluster>("mccluster");

         // Loop over clusters associated to this shower
         for (size_t j = 0; j < ass_showerreco_v.at(i).size(); j++ ){

           auto clus_id = ass_showerreco_v.at(i).at(j); 
           auto iclus = ev_clus->at(clus_id);
           
           int plane = iclus.Plane().Plane ;
           if ( plane != 2 ) continue;

           pur_ctr_v.clear();
           pur_ctr_v.resize(ass_mcclus_v.size()+1,0) ;

           int max_hits = -1;
           int max_cid = -1 ;

           // Loop through all hits associared to the cluster 
           for ( int k = 0; k < ass_imageclus_v.at(clus_id).size(); k++ ){

             auto hid = ass_imageclus_v.at(clus_id).at(k) ; 
             auto h = ev_hit->at(hid);
             
             if ( _mc_hit_map.find(hid) != _mc_hit_map.end() ){

               auto mcclus_id = _mc_hit_map[hid] ;

               pur_ctr_v[mcclus_id]++ ; 

               if( pur_ctr_v[ mcclus_id] > max_hits ){
                 max_hits = pur_ctr_v[mcclus_id];
                 max_cid = mcclus_id ; 
               }
             }
             else {
               auto mcclus_id = ass_mcclus_v.size() ;
               pur_ctr_v[mcclus_id]++ ; 
               if( pur_ctr_v[mcclus_id] > max_hits ){
                 max_hits = pur_ctr_v[mcclus_id];
                 max_cid = mcclus_id ; 
               }
             }
           }

           auto clocktick = larutil::DetectorProperties::GetME()->SamplingRate() * 1.e-3; //time sample in us
           float mc_clus_e = -999.;

           if ( max_cid != ass_mcclus_v.size() && max_cid != -1 ){

             auto tot_mc_hits =  ass_mcclus_v[max_cid].size(); 
             auto tot_reco_hits = ass_imageclus_v[clus_id].size();
             
             _shr_purity   = float(max_hits) / tot_reco_hits ;
             _shr_complete = float(max_hits) / tot_mc_hits ;

             auto mcclus = ev_mcc->at(max_cid) ;
             _shr_type   = mcclus.StartOpeningAngle() ; // set opening angle to track (0) or shower(1) in mccluster builder
             auto shr_index = mcclus.Width() ;          // index of track or shower  

	     float shr_ancestor_pdg = -1;

             if( _shr_type == 0 ){
               auto mct = ev_mct->at(shr_index) ;
               _shr_origin = mct.Origin(); 
               _shr_mother_pdg = mct.MotherPdgCode() ; 
               _shr_pdg = mct.PdgCode() ; 
             }
             else{
               auto mcs = ev_mcs->at(shr_index) ;
               _shr_origin = mcs.Origin(); 
               _shr_pdg = mcs.PdgCode() ; 
               _shr_mother_pdg = mcs.MotherPdgCode() ; 
               shr_ancestor_pdg = mcs.AncestorPdgCode() ; 
               _shr_from_pi0 = _shr_mother_pdg == 111 ? 1 : 0 ;
               _shr_trueE = mcs.Start().E() ;
               _shr_trueE_detProf = mcs.DetProfile().E();
	       _shr_true_detProf_startx = mcs.DetProfile().X();
	       _shr_true_detProf_starty = mcs.DetProfile().Y();
	       _shr_true_detProf_startz = mcs.DetProfile().Z();
	       _shr_true_startx = mcs.Start().X();
	       _shr_true_starty = mcs.Start().Y();
	       _shr_true_startz = mcs.Start().Z();

           auto tot_dir = sqrt( pow(mcs.DetProfile().Px(),2) +  pow(mcs.DetProfile().Py(),2) +  pow(mcs.DetProfile().Pz(),2) ); 

	       _shr_true_detProf_dirx = mcs.DetProfile().Px() / tot_dir;
	       _shr_true_detProf_diry = mcs.DetProfile().Py() / tot_dir;
	       _shr_true_detProf_dirz = mcs.DetProfile().Pz() / tot_dir;

           _shr_dir_res = sqrt ( pow(_shr_true_detProf_dirx - _shr_dirx,2) + 
								 pow(_shr_true_detProf_diry - _shr_diry,2) + 
                                 pow(_shr_true_detProf_dirz - _shr_dirz,2) ) ;

           auto sce_corr_det = _SCE->GetPosOffsets(_shr_true_detProf_startx,_shr_true_detProf_starty,_shr_true_detProf_startz);
           auto sce_corr = _SCE->GetPosOffsets(_shr_true_startx,_shr_true_starty,_shr_true_startz);

           _shr_true_detProf_startx += (_vtxtimecm + 0.7 - sce_corr_det.at(0));
           _shr_true_detProf_starty += sce_corr_det.at(1);
           _shr_true_detProf_startz += sce_corr_det.at(2);

           _shr_start_res = sqrt ( pow(_shr_true_detProf_startx - _shr_startx,2) + 
								   pow(_shr_true_detProf_starty - _shr_starty,2) + 
                                   pow(_shr_true_detProf_startz - _shr_startz,2) );

           _shr_true_startx += (_vtxtimecm + 0.7 - sce_corr.at(0));
           _shr_true_starty += sce_corr.at(1);
           _shr_true_startz += sce_corr.at(2);

	       used_mcs_v.emplace_back(shr_index);
              }
             mc_clus_e = 0;

	     // Fill perfect clustering info for the mccluster corresponding to true
             for ( auto const & mcc_hid : ass_mcclus_v[max_cid] ){
               auto mch = ev_hit->at(mcc_hid) ;
               float lifetime_corr = exp( mch.PeakTime() * clocktick / _lifetime_corr);
               float electrons = mch.Integral() * _gain; //mcc8 value
               float dQ = electrons * lifetime_corr * 23.6 * 1e-6 ;
               float dE = dQ / _recomb ; // 0.62 -> recomb factor
               mc_clus_e += dE ;
             }   
             _shr_perfect_clustering_E = mc_clus_e ;
          
	     if ( _shr_origin == 1 && ( shr_ancestor_pdg == 111 || shr_ancestor_pdg == 22 || shr_ancestor_pdg == 11) ){
	       _shr_n_true = 1; 
	       _shr_n_reco = 1;
	     }
           }

           if( _shr_type == -999 ) _n_shr_noise++;
           else if ( _shr_origin == 2 ) _n_shr_cosmic ++ ;
           else if ( _shr_origin == 1 && _shr_type == 0 ) _n_shr_nutrk++;
           else if ( _shr_origin == 1 && _shr_type == 1 && _shr_from_pi0 == 0 ) _n_shr_nushr++; 
           else if ( _shr_origin == 1 && _shr_type == 1 && _shr_from_pi0 == 1 ) _n_shr_pi0++; 
         }
       }
       _shower_tree->Fill() ;
     }
   }

   // If the number of identified mcs's produced at neutrino vtx is more than reco'd showers, 
   // add some more info to the shower tree. This is for shwoer reco efficiency later
   if ( _n_mcs_at_vtx > used_mcs_v.size() && _mc_sample ){
     auto ev_mcs = storage->get_data<event_mcshower>("mcreco") ;
     if ( !ev_mcs || !ev_mcs->size() ) {std::cout<<"No MCShower!" <<std::endl ; return false; }

     for ( int i = 0 ; i < all_mcs_v.size() ; i++ ){

       int id = all_mcs_v.at(i);
       if( std::find(used_mcs_v.begin(),used_mcs_v.end(),id) != used_mcs_v.end() )
         continue;
       else{
         _shr_n_reco = 0;
         _shr_n_true = 1;
         _shr_trueE_detProf = ev_mcs->at(id).DetProfile().E() ;
         _shr_trueE = ev_mcs->at(id).Start().E() ;
         _shr_true_startx = ev_mcs->at(id).Start().X();
         _shr_true_starty = ev_mcs->at(id).Start().Y();
         _shr_true_startz = ev_mcs->at(id).Start().Z();
         _shr_true_detProf_startx = ev_mcs->at(id).DetProfile().X() ;
         _shr_true_detProf_starty = ev_mcs->at(id).DetProfile().Y() ;
         _shr_true_detProf_startz = ev_mcs->at(id).DetProfile().Z() ;

         auto sce_corr_det = _SCE->GetPosOffsets(_shr_true_detProf_startx,_shr_true_detProf_starty,_shr_true_detProf_startz);
         auto sce_corr = _SCE->GetPosOffsets(_shr_true_startx,_shr_true_starty,_shr_true_startz);

         _shr_true_detProf_startx += (_vtxtimecm + 0.7 - sce_corr_det.at(0));
         _shr_true_detProf_starty += sce_corr_det.at(1);
         _shr_true_detProf_startz += sce_corr_det.at(2);

         _shr_true_startx += (_vtxtimecm + 0.7 - sce_corr.at(0));
         _shr_true_starty += sce_corr.at(1);
         _shr_true_startz += sce_corr.at(2);

         _shower_tree->Fill();
       }   
     }   
   }

   // Fill info needed to assess GENIE/flux uncertainties
   if ( _get_genie_info ) {

      if ( ! _get_preselection_flux_info ) {

        auto ev_genie_wgt= storage->get_data<event_mceventweight>("genieeventweight");

        if( !ev_genie_wgt || !ev_genie_wgt->size() ){
          std::cout<<"No GENIE eventweights..." <<std::endl;
          _tree->Fill();    
          return false;
        }

        auto wgt  = ev_genie_wgt->at(0).GetWeights();

        int it = 0;
        for ( auto const & m : wgt ) {
          auto w_v = m.second ;
          _sel_evts_p1[it] = (w_v.at(0)) ;
          _sel_evts_m1[it] = (w_v.at(1)) ;

          // These are reset to 1 every new event
          //_genie_weight_up *= std::max(_sel_evts_p1[it],_sel_evts_m1[it]) ; 
          //_genie_weight_dn *= std::min(_sel_evts_p1[it],_sel_evts_m1[it]) ; 
          _genie_weight_up *= _sel_evts_p1[it] ; 
          _genie_weight_dn *= _sel_evts_m1[it] ; 

          it++;
         }
         //std::cout<<"Genie weights:  "<<_genie_weight_up <<", "<<_genie_weight_dn <<std::endl ;

         if ( _signal ){

           int it = 0;
           for ( auto const & m : wgt ) { 
             auto w_v = m.second ;
             _sig_evts_p1[it] += (w_v.at(0)) ; 
             _sig_evts_m1[it] += (w_v.at(1)) ;
             it++;
           }
         }
         else{

           int it = 0;
           for ( auto const & m : wgt ) { 
             auto w_v = m.second ;
             _bkgd_evts_p1[it] += (w_v.at(0)) ; 
             _bkgd_evts_m1[it] += (w_v.at(1)) ;
             it++;
           }   
         }
       }

       if ( _get_single_shower_info || _get_pi0_info || _get_preselection_flux_info ){

         auto ev_flux_wgt= storage->get_data<event_mceventweight>("fluxeventweight");

         if( !ev_flux_wgt || !ev_flux_wgt->size() ){
           std::cout<<"No FLUX eventweights..." <<std::endl;
           _tree->Fill();    
           return false;
         }

         auto wgt_flux  = ev_flux_wgt->at(0).GetWeights();

         std::vector<float> b_unisim_tot_weight(1000,1);
         std::vector<float> s_unisim_tot_weight(1000,1);

         // Rewrite with a map
         for ( auto const & m : wgt_flux ) {

           if (m.first == "bnbcorrection_FluxHist" )
             continue;

           for ( int jj = 0; jj < m.second.size(); jj++ ){

             _flux_weights[jj] *= m.second.at(jj) ;

             // These are the 5 hadron values -- they may be correlated. Vary these 5 individually.
             if ( find(_unisim_label_v.begin(),_unisim_label_v.end(),m.first) != _unisim_label_v.end() ){
                 if (_signal )
                   s_unisim_tot_weight[jj] *= m.second.at(jj) ;
                 else
                   b_unisim_tot_weight[jj] *= m.second.at(jj) ;
             }   
             else{
               if (_signal)
                 _s_weights_by_universe[_label_map[m.first]][jj] += m.second.at(jj);
               else
                 _b_weights_by_universe[_label_map[m.first]][jj] += m.second.at(jj);
             }
           }
         }
         
         float mean = 0;
 
         for ( int jj = 0; jj < 1000; jj++){
           if(_signal)
           _s_weights_by_universe[0][jj] += s_unisim_tot_weight[jj] ;
           else
           _b_weights_by_universe[0][jj] += b_unisim_tot_weight[jj] ;
             
          mean += (_flux_weights[jj]/1000);
         }

         float sigma  = 0;

         for ( int jj = 0; jj < 1000; jj++)
           sigma += ( _flux_weights[jj] - mean ) * ( _flux_weights[jj] - mean );

         sigma /= 1000;

         _flux_weight_up = 1 + sqrt( sigma ) ; 
         _flux_weight_dn = 1 - sqrt( sigma ) ; 
       }

     }

    _tree->Fill();    

    return true;
  }

  bool BackgroundTruthMatchBT::finalize() {

    std::cout<<"Events: "<<_event<<", ev with no duplicates: "<<_event_no_dup<<std::endl ;
    std::cout<<"Signals: "<<_n_signals<<std::endl ;
    std::cout<<"Total CCpi0 : "<<_n_cc1pi0<<std::endl; 

    // Note that cc other includes secondary pi0s.
    std::cout<<"\nBackgrounds: "<<std::endl;
    std::cout<<"0) Noise : "<<_n_noise<< std::endl;
    std::cout<<"1) Cosmic : "<<_n_cosmic<< std::endl;
    std::cout<<"2) CC 1pi0 : "<<_n_cc1pi0<<std::endl;
    std::cout<<"3) NC 1pi0 : "<<_n_nc1pi0<<std::endl;
    std::cout<<"4) CC 1pi0 out FV: "<<_n_cc1pi0_outFV<<std::endl;
    std::cout<<"5) CC mult pi0: "<<_n_multpi0<<std::endl;
    std::cout<<"6) Nue: "<<_n_nue<<std::endl;
    std::cout<<"7) Antinumu: "<<_n_antimu<<std::endl;
    std::cout<<"8) CC Cex: "<<_n_cccex<<std::endl;
    std::cout<<"9) NC Cex: "<<_n_nccex<<std::endl;
    std::cout<<"10) CC Gamma : "<<_n_gamma<<std::endl;
    std::cout<<"11) Kaon Decay: "<<_n_kaondecay<<std::endl;
    std::cout<<"12) CC Other : "<<_n_ccother<<std::endl;
    std::cout<<"13) NC Other : "<<_n_ncother<<std::endl;
    std::cout<<"14) Other: "<<_n_other<< std::endl;

    std::cout<<"ONLY 1 GAMMA!!! "<<_1gamma<<std::endl;
    auto funcs = 6; 
    float dataPOT = 1.616;
    float mcbnbcos_POT = 20.7948 ; //4.23214; 
    float mc_to_onbeam = dataPOT/mcbnbcos_POT;

    if ( _get_genie_info && (_get_single_shower_info || _get_pi0_info) ) {  // && _eventweight_producer == "fluxeventweight" ){
      for( int i = 0; i < funcs; i++){
        std::cout<<"FLUX! "<<_flux_by_universe[i][0]<<std::endl ;
        for( int j= 0; j < 1000; j++){

          float eff = _s_weights_by_universe[i][j] / _t_weights_by_universe[i][j] ;
          _sig_v[i][j] = _s_weights_by_universe[i][j];
		  _tot_v[i][j] = _t_weights_by_universe[i][j];
		  _eff_v[i][j] = eff ;

          _xsec_v[i][j] = float( _N -  mc_to_onbeam*_b_weights_by_universe[i][j])/eff/ _flux_by_universe[i][j]/(8.855e+29);
          _perc_v[i][j] = ( _xsec_v[i][j] - _N_xsec )/ _N_xsec *100;
        }
      }

      _univ->Fill();
      //if ( _get_genie_info && _eventweight_producer == "genieeventweight" ){

      std::cout<<"SIGNAL GENIE : "<<std::endl ;
      for( int i = 0 ; i < _sel_evts_m1.size(); i++)
        std::cout<<_sig_evts_m1[i]<<", " ;

      std::cout<<std::endl ;
      for( int i = 0 ; i < _sel_evts_p1.size(); i++)
        std::cout<<_sig_evts_p1[i]<<", " ;

      std::cout<<std::endl;

      std::cout<<"BACKGROUND: "<<std::endl ;
      for( int i = 0 ; i < _sel_evts_m1.size(); i++) 
        std::cout<<_bkgd_evts_m1[i]<<", " ;

      std::cout<<std::endl ;
      for( int i = 0 ; i < _sel_evts_p1.size(); i++) 
        std::cout<<_bkgd_evts_p1[i]<<", " ;

      std::cout<<std::endl ;

    }

    if ( _fout ){
      std::cout<<"WRiting "<<std::endl;
      _fout->cd();
      _tree->Write();
      _univ->Write();
      _shower_tree->Write();
    }
  
    return true;
  }

}
#endif
